{
  "helpItems": {
    "node:uv-coordinates": {
      "title": "UV Coords",
      "titleType": "node",
      "tagline": "Gives you the position of each pixel as a vec2 (0–1), so you can drive patterns and effects from screen position.",
      "description": "This node outputs the current position on the screen as a vec2: two numbers (x, y) that go from 0 to 1 across the image. UV coordinates are the standard way to feed \"where am I on the screen?\" into pattern nodes like Noise, Translate, or Scale. Bottom-left is (0, 0), top-right is (1, 1).",
      "inputs": [],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "Position on screen (0–1 in x and y). Connect to Noise, Translate, Scale, or any node that takes vec2 coordinates.",
          "suggestedTargets": [
            "node:translate",
            "node:scale",
            "node:rotate",
            "node:multiply",
            "node:noise",
            "node:hexagonal-grid",
            "node:wave-patterns"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          {
            "id": "a",
            "type": "uv-coordinates"
          },
          {
            "id": "b",
            "type": "noise"
          },
          {
            "id": "c",
            "type": "color-map"
          },
          {
            "id": "d",
            "type": "final-output"
          }
        ],
        "connections": [
          {
            "from": "a",
            "fromPort": "out",
            "to": "b",
            "toPort": "in"
          },
          {
            "from": "b",
            "fromPort": "out",
            "to": "c",
            "toPort": "in"
          },
          {
            "from": "c",
            "fromPort": "out",
            "to": "d",
            "toPort": "in"
          }
        ]
      },
      "relatedItems": [
        "type:vec2",
        "node:fragment-coordinates",
        "node:resolution"
      ],
      "examples": [
        "Connect to Noise, then Color Map, then Output to see a grayscale pattern.",
        "Feed into Translate or Scale to shift or zoom patterns.",
        "Use with Polar Coords or Hexagonal Grid for radial or tiled effects."
      ],
      "advanced": "UV is normalized (0–1). Use Fragment Coords when you need pixel coordinates or aspect-ratio corrections; use Resolution with Divide for that."
    },
    "node:time": {
      "title": "Time",
      "titleType": "node",
      "tagline": "A number that keeps increasing over time—use it to animate motion, waves, or any value that should change as the shader runs.",
      "description": "Time outputs a single number (a float) that increases every frame. You can multiply it to speed up or slow down animations, or feed it into Sine/Cosine for smooth waves. It has no inputs and no parameters—it always gives you the current time.",
      "inputs": [],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "Current time in seconds. Connect to Sine, Cosine, Multiply, or Noise to drive animation.",
          "suggestedTargets": [
            "node:sine",
            "node:cosine",
            "node:multiply",
            "node:noise",
            "node:wave-patterns",
            "node:scanlines",
            "node:particle-system"
          ]
        }
      ],
      "relatedItems": [
        "type:float",
        "node:sine",
        "node:cosine",
        "node:multiply"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "time" },
          { "id": "b", "type": "sine" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect to Sine or Cosine, then Color Map and Output for a moving wave.",
        "Multiply Time by a small float to slow down (or large to speed up) animation.",
        "Feed into Noise Time input for animated noise, or into Translate for moving patterns."
      ]
    },
    "node:resolution": {
      "title": "Resolution",
      "titleType": "node",
      "tagline": "Use this to access screen resolution for aspect ratio calculations and pixel-perfect effects",
      "description": "Outputs the screen resolution as a vec2 containing the width and height in pixels. This is essential for maintaining aspect ratios, calculating pixel sizes, and creating resolution-independent effects. The x component represents width, and the y component represents height. Connect Fragment Coords to Divide (a) and Resolution to Divide (b) for aspect-correct UV; or feed Resolution into UV or Polar Coords for pixel-aware effects.",
      "inputs": [],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "Screen resolution as (width, height) in pixels. Connect to Divide with Fragment Coords for aspect-correct coords, or to Bayer Dither and similar effects.",
          "suggestedTargets": [
            "node:divide",
            "node:uv-coordinates",
            "node:polar-coordinates",
            "node:bayer-dither"
          ]
        }
      ],
      "relatedItems": [
        "type:vec2",
        "node:uv-coordinates",
        "node:fragment-coordinates",
        "node:divide"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "resolution" },
          { "id": "b", "type": "translate" },
          { "id": "c", "type": "noise" },
          { "id": "d", "type": "color-map" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      },
      "examples": [
        "Divide Fragment Coords by Resolution to get normalized 0–1 coords that respect aspect ratio.",
        "Use with UV or Polar Coords to scale or dither in pixel space.",
        "Feed width/height into Bayer Dither or other pixel-aware effects for consistent look at any resolution."
      ],
      "advanced": "Resolution is in pixels (x = width, y = height). For aspect-correct UV, use Fragment Coords divided by Resolution; for simple 0–1 space use UV Coords."
    },
    "node:fragment-coordinates": {
      "title": "Frag Coords",
      "titleType": "node",
      "tagline": "Perfect for accessing raw pixel coordinates for pixel-level effects and precise positioning",
      "description": "Outputs the fragment coordinates (gl_FragCoord.xy) as a vec2, representing the actual pixel position on the screen. Unlike UV coordinates which are normalized, fragment coordinates are in actual pixel units, with (0,0) at the bottom-left corner. This is useful for pixel-perfect effects, precise positioning, and calculations that require actual screen dimensions. Connect to Divide with Resolution for aspect-correct 0–1 coords, or feed into Translate, Bayer Dither, or Polar Coords for pixel-aware effects.",
      "inputs": [],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "Fragment coordinates in pixel units (x, y). Connect to Divide (a) with Resolution (b) for normalized coords, or to pixel-based effects like Bayer Dither.",
          "suggestedTargets": [
            "node:divide",
            "node:translate",
            "node:bayer-dither",
            "node:polar-coordinates"
          ]
        }
      ],
      "relatedItems": [
        "type:vec2",
        "node:uv-coordinates",
        "node:resolution"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "fragment-coordinates" },
          { "id": "b", "type": "translate" },
          { "id": "c", "type": "noise" },
          { "id": "d", "type": "color-map" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      },
      "examples": [
        "Divide by Resolution for aspect-correct 0–1 coordinates; connect to Noise or Translate for pixel-aligned effects.",
        "Use for Bayer Dither or Polar Coords when you need actual pixel position.",
        "Feed into nodes that expect pixel units (e.g. precise positioning or resolution-dependent patterns)."
      ],
      "advanced": "Fragment coords are in pixel space (bottom-left origin). Use when you need real pixel position or aspect ratio; use UV Coords when 0–1 normalized space is enough."
    },
    "node:orbit-camera": {
      "title": "Orbit Camera",
      "titleType": "node",
      "tagline": "Ray origin and direction from a time-driven orbit for 3D raymarching",
      "description": "Outputs ray origin (ro) and ray direction (rd) from a camera that orbits around a target, driven by time. Parameters: orbit radius, speed, target position, and optional inclination (tilt). Connect Screen position (e.g. from UV Coords) for correct perspective; connect ro and rd to SDF or other raymarch nodes to share the same camera.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Screen position for per-pixel ray direction (e.g. UV or normalized device coords)",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:fragment-coordinates"
          ]
        }
      ],
      "outputs": [
        {
          "name": "ro",
          "type": "vec3",
          "description": "Ray origin (camera position)",
          "suggestedTargets": [
            "node:box-torus-sdf"
          ]
        },
        {
          "name": "rd",
          "type": "vec3",
          "description": "Ray direction (normalized, per fragment when Screen position is connected)",
          "suggestedTargets": [
            "node:box-torus-sdf"
          ]
        }
      ],
      "relatedItems": [
        "node:box-torus-sdf",
        "node:sphere-raymarch",
        "type:vec3"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "orbit-camera" },
          { "id": "c", "type": "box-torus-sdf" },
          { "id": "d", "type": "color-map" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "ro", "to": "c", "toPort": "ro" },
          { "from": "b", "fromPort": "rd", "to": "c", "toPort": "rd" },
          { "from": "a", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV to in and ro/rd to an SDF or raymarch node for an orbiting 3D view.",
        "Multiply orbit speed by Time for controllable rotation; adjust radius and target for framing.",
        "Use with Color Map on the SDF output for a simple orbiting scene."
      ],
      "advanced": "Orbit moves the camera around a target over time; use Look-at Camera when you want a fixed camera position and direction."
    },
    "node:look-at-camera": {
      "title": "Look-at Camera",
      "titleType": "node",
      "tagline": "Ray origin and direction from a fixed camera looking at a target (no orbit)",
      "description": "Outputs ray origin (ro) and ray direction (rd) from a fixed camera position looking at a target. Use for drive-style or fixed-view 3D (e.g. bokeh lights, raymarching). Connect Screen position (e.g. UV Coords, or UV minus rain offset) for perspective. Parameters: position (vec3), lookat (vec3), zoom.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Screen position for per-pixel ray direction (e.g. UV or normalized device coords)",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:fragment-coordinates"
          ]
        }
      ],
      "outputs": [
        {
          "name": "ro",
          "type": "vec3",
          "description": "Ray origin (camera position)",
          "suggestedTargets": [
            "node:box-torus-sdf",
            "node:bokeh-point",
            "node:drive-home-lights"
          ]
        },
        {
          "name": "rd",
          "type": "vec3",
          "description": "Ray direction (normalized, per fragment when Screen position is connected)",
          "suggestedTargets": [
            "node:box-torus-sdf",
            "node:bokeh-point",
            "node:drive-home-lights"
          ]
        }
      ],
      "relatedItems": [
        "node:orbit-camera",
        "node:box-torus-sdf",
        "node:sphere-raymarch",
        "type:vec3"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "look-at-camera" },
          { "id": "c", "type": "box-torus-sdf" },
          { "id": "d", "type": "color-map" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "ro", "to": "c", "toPort": "ro" },
          { "from": "b", "fromPort": "rd", "to": "c", "toPort": "rd" },
          { "from": "a", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV to in; connect ro and rd to an SDF or Bokeh node for 3D raymarching.",
        "Use with Rain Drops: subtract rain UV offset from UV, then feed into Look-at Camera for windshield effect.",
        "Often used with Bokeh Point or Drive Home Lights for drive-style scenes."
      ],
      "advanced": "Look-at keeps the camera fixed; use Orbit Camera when you want the camera to move around a target over time."
    },
    "node:rain-drops": {
      "title": "Rain Drops",
      "titleType": "node",
      "tagline": "Procedural rain-on-glass UV offset for windshield distortion",
      "description": "Outputs a vec2 UV offset for rain drops on glass. Subtract from UV and feed to Look-at Camera for windshield distortion. Parameters: scale, seed, speed, layers, drop size variation, quantity per layer. Reference: Shadertoy The Drive Home.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "UV coordinates",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates"
          ]
        },
        {
          "name": "time",
          "type": "float",
          "description": "Time for animation (default: internal time)",
          "suggestedSources": [
            "node:time",
            "type:float"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "UV offset to subtract before camera (uv - out → camera)",
          "suggestedTargets": [
            "node:subtract",
            "node:look-at-camera"
          ]
        }
      ],
      "relatedItems": [
        "node:look-at-camera",
        "node:drive-home-lights",
        "type:vec2"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "rain-drops" },
          { "id": "c", "type": "length" },
          { "id": "d", "type": "color-map" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      },
      "examples": [
        "Feed UV into in and subtract the output from UV before connecting to Look-at Camera for windshield rain distortion.",
        "Connect Time to the time input to animate drops; tune scale and quantity for density.",
        "Use with Drive Home Lights: same UV pipeline (UV − rain offset → camera) for a rainy drive scene."
      ]
    },
    "node:bokeh-point": {
      "title": "Bokeh Point",
      "titleType": "node",
      "tagline": "Soft bokeh disc intensity for one 3D point light",
      "description": "Outputs 0–1 intensity for a single 3D point as seen from a ray (ro, rd). Multiply by light color. Parameters: size, blur, inner falloff. Reference: Shadertoy The Drive Home.",
      "inputs": [
        {
          "name": "ro",
          "type": "vec3",
          "description": "Ray origin. Connect ro from Look-at Camera or Orbit Camera.",
          "suggestedSources": [
            "node:look-at-camera",
            "node:orbit-camera"
          ]
        },
        {
          "name": "rd",
          "type": "vec3",
          "description": "Ray direction. Connect rd from the same camera as ro.",
          "suggestedSources": [
            "node:look-at-camera",
            "node:orbit-camera"
          ]
        },
        {
          "name": "point",
          "type": "vec3",
          "description": "3D point position. Connect Constant Vec3 or a 3D position node.",
          "suggestedSources": [
            "type:vec3",
            "node:constant-vec3"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "Bokeh intensity 0–1. Connect to Multiply (with color) or Mix, then to Final Output.",
          "suggestedTargets": [
            "node:multiply",
            "node:mix",
            "node:final-output"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "look-at-camera" },
          { "id": "c", "type": "constant-vec3" },
          { "id": "d", "type": "bokeh-point" },
          { "id": "e", "type": "color-map" },
          { "id": "f", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "ro", "to": "d", "toPort": "ro" },
          { "from": "b", "fromPort": "rd", "to": "d", "toPort": "rd" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "point" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" },
          { "from": "e", "fromPort": "out", "to": "f", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:look-at-camera",
        "node:drive-home-lights",
        "type:float"
      ],
      "examples": [
        "Connect Look-at or Orbit Camera ro/rd, and a Constant Vec3 as the 3D point position; multiply output by a color and add to your scene.",
        "Use several Bokeh Point nodes with different positions and colors for multiple lights.",
        "Feed the float output into Color Map or Multiply with a color, then add to Final Output or mix with background."
      ]
    },
    "node:drive-home-lights": {
      "title": "Drive Home Lights",
      "titleType": "node",
      "tagline": "Bokeh street, head, tail, and environment lights in one node",
      "description": "Sums street lights, headlights, tail/brake lights, and environment lights as bokeh discs. Connect ro/rd from Look-at Camera and time. Parameters: time scale, lane bias. Reference: Shadertoy The Drive Home.",
      "inputs": [
        {
          "name": "ro",
          "type": "vec3",
          "description": "Ray origin. Connect from Look-at Camera or Orbit Camera.",
          "suggestedSources": [
            "node:look-at-camera",
            "node:orbit-camera"
          ]
        },
        {
          "name": "rd",
          "type": "vec3",
          "description": "Ray direction. Connect from the same camera as ro.",
          "suggestedSources": [
            "node:look-at-camera",
            "node:orbit-camera"
          ]
        },
        {
          "name": "time",
          "type": "float",
          "description": "Time for animation. Connect Time node for driving light motion.",
          "suggestedSources": [
            "node:time",
            "type:float"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec3",
          "description": "Additive light color (add sky gradient in graph)",
          "suggestedTargets": [
            "node:add",
            "node:final-output",
            "node:mix"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "look-at-camera" },
          { "id": "c", "type": "time" },
          { "id": "d", "type": "drive-home-lights" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "ro", "to": "d", "toPort": "ro" },
          { "from": "b", "fromPort": "rd", "to": "d", "toPort": "rd" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "time" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:look-at-camera",
        "node:bokeh-point",
        "node:rain-drops",
        "type:vec3"
      ],
      "examples": [
        "Connect ro/rd from Look-at Camera and Time; plug output into Final Output or add with a sky gradient.",
        "Combine with Rain Drops: use (UV − rain offset) as the screen input to the same Look-at Camera for a rainy drive.",
        "Tune time scale and lane bias parameters to match the desired drive mood."
      ]
    },
    "node:constant-float": {
      "title": "Float",
      "titleType": "node",
      "tagline": "A single number you set with a slider. Use it wherever another node needs a float (speed, strength, threshold, etc.).",
      "description": "Float gives you one number that you control with the Value slider. No inputs needed—just add the node and set the value. Connect it to Multiply to scale something, to Mix to set blend amount, to Translate or Scale for offsets, or to any port that expects a float.",
      "inputs": [],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The number set by the Value parameter. Connect to Add, Multiply, Mix, Translate, Scale, or any float input.",
          "suggestedTargets": [
            "node:add",
            "node:multiply",
            "node:mix",
            "node:sine",
            "node:clamp",
            "node:translate",
            "node:scale"
          ]
        }
      ],
      "parameters": [
        {
          "name": "Value",
          "description": "The constant number this node outputs. Change it to set speed, strength, offset, or any single value you feed downstream (e.g. to Multiply, Mix, or Translate)."
        }
      ],
      "relatedItems": [
        "type:float",
        "node:constant-vec2",
        "node:constant-vec3",
        "node:constant-vec4"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "constant-float" },
          { "id": "b", "type": "sine" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "examples": [
        "Set Value and connect to Multiply to scale noise or animation speed; to Mix for blend amount; to Translate or Scale for offset.",
        "Use as fallback when a float input is unconnected (e.g. Mix amount, Sine frequency).",
        "Connect to Sine or Cosine for a fixed phase or frequency when you don't need Time."
      ]
    },
    "node:constant-vec2": {
      "title": "Vec2",
      "titleType": "node",
      "tagline": "Ideal for providing constant 2D vectors for coordinates, offsets, and 2D parameters",
      "description": "Outputs a constant vec2 value with adjustable x and y components. This node is perfect for providing fixed 2D values such as coordinate offsets, scale factors, translation amounts, or any pair of related float values. Both x and y components can be independently adjusted between -1000.0 and 1000.0. Connect to Translate or Scale for offsets, to Distance (a or b) for a center point, or to Noise and other nodes that take vec2.",
      "inputs": [],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "The constant vec2 value with (x, y) components. Connect to Translate, Scale, Distance, or any vec2 input.",
          "suggestedTargets": [
            "node:translate",
            "node:scale",
            "node:rotate",
            "node:uv-coordinates",
            "node:add",
            "node:multiply"
          ]
        }
      ],
      "relatedItems": [
        "type:vec2",
        "node:constant-float",
        "node:constant-vec3",
        "node:constant-vec4"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "constant-vec2" },
          { "id": "b", "type": "translate" },
          { "id": "c", "type": "uv-coordinates" },
          { "id": "d", "type": "noise" },
          { "id": "e", "type": "color-map" },
          { "id": "f", "type": "final-output" }
        ],
        "connections": [
          { "from": "c", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" },
          { "from": "e", "fromPort": "out", "to": "f", "toPort": "in" }
        ]
      },
      "examples": [
        "Set x, y, z and connect to Translate or Scale for 2D offset/scale; to Rotate for center; to UV-based nodes for fixed vec2.",
        "Use as a constant offset to Add with UV or other vec2 for shifted patterns.",
        "Feed into Noise, Hexagonal Grid, or Wave Patterns as a fixed coordinate or scale input."
      ]
    },
    "node:constant-vec3": {
      "title": "Vec3",
      "titleType": "node",
      "tagline": "Perfect for providing constant 3D vectors for positions, directions, or RGB color values",
      "description": "Outputs a constant vec3 value with adjustable x, y, and z components. This node is useful for providing fixed 3D values such as positions, direction vectors, RGB color values (before conversion to color nodes), or any triple of related float values. All three components can be independently adjusted between -1000.0 and 1000.0. Connect to Bokeh Point (point), Look-at Camera (position/lookat), or any 3D node that expects a vec3.",
      "inputs": [],
      "outputs": [
        {
          "name": "out",
          "type": "vec3",
          "description": "The constant vec3 value with (x, y, z) components. Connect to Bokeh Point, camera nodes, or 3D shape/lighting inputs.",
          "suggestedTargets": [
            "node:oklch-color-map-bezier",
            "node:color-map",
            "node:mix",
            "node:normalize",
            "node:final-output"
          ]
        }
      ],
      "relatedItems": [
        "type:vec3",
        "node:constant-float",
        "node:constant-vec2",
        "node:constant-vec4",
        "node:oklch-color"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "constant-vec3" },
          { "id": "b", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" }
        ]
      },
      "examples": [
        "Set (x, y, z) for RGB or position; connect to Color Map, Mix, Bokeh Point position, or Final Output for a solid color.",
        "Use as light or object position in 3D (e.g. Bokeh Point point input) or as RGB for tinting.",
        "Connect to OKLCH Color Map Bezier or other nodes that take vec3 color or position."
      ]
    },
    "node:constant-vec4": {
      "title": "Vec4",
      "titleType": "node",
      "tagline": "Use this to provide constant 4D vectors for RGBA colors, homogeneous coordinates, or 4D data",
      "description": "Outputs a constant vec4 value with adjustable x, y, z, and w components. This node is essential for providing fixed 4D values such as RGBA color values, homogeneous coordinates for 3D transformations, or any quadruple of related float values. All four components can be independently adjusted between -1000.0 and 1000.0, with w defaulting to 1.0. Connect to Blend Mode or other nodes that accept vec4 for color or homogeneous data.",
      "inputs": [],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The constant vec4 value with (x, y, z, w) components. Connect to Blend Mode or any vec4 input.",
          "suggestedTargets": [
            "node:mix",
            "node:blend-mode",
            "node:gradient-mask",
            "node:oklch-color-map-bezier"
          ]
        }
      ],
      "relatedItems": [
        "type:vec4",
        "node:constant-float",
        "node:constant-vec2",
        "node:constant-vec3",
        "node:bezier-curve"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "noise" },
          { "id": "c", "type": "constant-vec4" },
          { "id": "d", "type": "oklch-color-map-bezier" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "lCurve" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      }
    },
    "node:oklch-color": {
      "title": "OKLCH Color",
      "titleType": "node",
      "tagline": "Ideal for creating perceptually uniform colors using the OKLCH color space",
      "description": "Defines a color value in the OKLCH (OK Lightness, Chroma, Hue) color space, which provides perceptually uniform color representation. This means that equal changes in the L, C, or H values result in visually similar changes in perceived color. The node outputs a vec3 containing (L, C, H) values, where L (lightness) ranges from 0.0 to 1.0, C (chroma/saturation) ranges from 0.0 to 0.4, and H (hue) ranges from 0.0 to 360.0 degrees. This color space is particularly useful for smooth color gradients and color interpolation. Connect to OKLCH Color Map Bezier or OKLCH Color Map Threshold for perceptually smooth gradients from a single value.",
      "inputs": [],
      "outputs": [
        {
          "name": "out",
          "type": "vec3",
          "description": "OKLCH color value as (lightness, chroma, hue). Connect to OKLCH Color Map nodes for smooth gradients.",
          "suggestedTargets": [
            "node:oklch-color-map-bezier",
            "node:oklch-color-map-threshold",
            "node:color-map",
            "node:mix"
          ]
        }
      ],
      "relatedItems": [
        "type:vec3",
        "node:oklch-color-map-bezier",
        "node:oklch-color-map-threshold",
        "node:constant-vec3"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "oklch-color" },
          { "id": "b", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" }
        ]
      },
      "examples": [
        "Set L, C, H and connect to OKLCH Color Map Bezier or Color Map for a base color in a gradient.",
        "Use with Mix or OKLCH Color Map Threshold for perceptually smooth color transitions.",
        "Combine several OKLCH Color nodes in a gradient chain for smooth, uniform steps."
      ],
      "advanced": "OKLCH is perceptually uniform: equal changes in L, C, or H look equally different to the eye, which makes gradients and interpolation smoother than in RGB."
    },
    "node:bezier-curve": {
      "title": "Bezier",
      "titleType": "node",
      "tagline": "Perfect for defining smooth easing curves for color interpolation and animation timing",
      "description": "Defines a cubic Bezier curve for smooth interpolation and easing functions. The node outputs a vec4 containing the two control points (x1, y1, x2, y2) that define the curve's shape. This curve can be used with color mapping nodes to create smooth color transitions, or with animation systems to define easing functions. The curve is visualized in a bezier editor interface where you can drag control points to adjust the curve shape. The curve maps input values (0-1) to output values (0-1) with customizable easing. Connect to OKLCH Color Map Bezier for smooth color ramps, or use with any node that accepts a curve definition.",
      "inputs": [],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "Bezier curve control points as (x1, y1, x2, y2). Connect to OKLCH Color Map Bezier or other curve-based nodes.",
          "suggestedTargets": [
            "node:oklch-color-map-bezier",
            "node:mix",
            "node:smoothstep"
          ]
        }
      ],
      "relatedItems": [
        "type:vec4",
        "node:oklch-color-map-bezier",
        "node:constant-vec4",
        "node:mix",
        "node:smoothstep"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "noise" },
          { "id": "c", "type": "bezier-curve" },
          { "id": "d", "type": "oklch-color-map-bezier" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "lCurve" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect to OKLCH Color Map Bezier as lCurve to shape how a value maps to color (ease-in, ease-out, custom).",
        "Use with Mix for smooth blend curves or with Smoothstep for custom easing.",
        "Drag control points in the editor to design the curve; the output vec4 drives the mapping in color or blend nodes."
      ],
      "advanced": "The curve maps 0–1 input to 0–1 output. Use it for easing (slow start/end) or for remapping values before color or blend; linear would be (0,0,1,1)."
    },
    "node:add": {
      "title": "Add",
      "titleType": "node",
      "tagline": "Adds two numbers (or two vec2/vec3/vec4 values). Use it to combine values or add an offset.",
      "description": "Add takes two inputs, a and b, and outputs their sum (a + b). If you leave the second input unconnected, the Second Value parameter is used instead. Handy for shifting a value (e.g. Time + 0.5) or combining two signals.",
      "inputs": [
        {
          "name": "a",
          "type": "float",
          "description": "First value. Connect Time, Float, Sine, or another node’s output.",
          "suggestedSources": [
            "type:float",
            "node:constant-float",
            "node:time",
            "node:multiply",
            "node:sine"
          ]
        },
        {
          "name": "b",
          "type": "float",
          "description": "Second value. If unconnected, the Second Value parameter is used.",
          "suggestedSources": [
            "type:float",
            "node:constant-float",
            "node:time",
            "node:multiply",
            "node:sine"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The sum a + b. Connect to Multiply, Mix, Translate, or other math/effect nodes.",
          "suggestedTargets": [
            "node:multiply",
            "node:mix",
            "node:translate",
            "node:final-output",
            "node:clamp"
          ]
        }
      ],
      "parameters": [
        {
          "name": "Second Value",
          "description": "Used for input b when nothing is connected. Set to 0.5 to shift the result by half; use with Time to offset animation phase."
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "constant-float" },
          { "id": "n3", "type": "add" },
          { "id": "n4", "type": "color-map" },
          { "id": "n5", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n3", "toPort": "a" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "b" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" },
          { "from": "n4", "fromPort": "out", "to": "n5", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:subtract",
        "node:multiply",
        "node:divide",
        "type:float"
      ],
      "examples": [
        "Connect Time to a and a constant to b (or Second Value) to shift animation in time.",
        "Add two Sine waves or two Noise outputs for combined patterns.",
        "Use with Translate: add a vec2 offset to UV for shifting the whole pattern."
      ]
    },
    "node:subtract": {
      "title": "Subtract",
      "titleType": "node",
      "tagline": "Ideal for calculating differences and offsets",
      "description": "Subtracts the second value from the first. Works with any numeric type through type promotion. Useful for calculating differences, applying negative offsets, and creating distance-based effects. Connect UV to a and a center (e.g. Constant Vec2) to b, then output to Length or Smoothstep for radial falloff; or connect (Noise − 0.5) to Color Map for centered patterns.",
      "inputs": [
        {
          "name": "a",
          "type": "float",
          "description": "The value to subtract from. Often UV, Time, or a pattern output.",
          "suggestedSources": [
            "type:float",
            "node:constant-float",
            "node:time",
            "node:add",
            "node:multiply",
            "node:uv-coordinates"
          ]
        },
        {
          "name": "b",
          "type": "float",
          "description": "The value to subtract. Often a center point (Constant Vec2), threshold, or offset.",
          "suggestedSources": [
            "type:float",
            "node:constant-float",
            "node:time",
            "node:add",
            "node:multiply"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The difference a − b. Connect to Absolute, Length, Color Map, or Smoothstep for falloffs.",
          "suggestedTargets": [
            "node:add",
            "node:multiply",
            "node:absolute",
            "node:distance",
            "node:clamp"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "constant-float" },
          { "id": "n3", "type": "subtract" },
          { "id": "n4", "type": "color-map" },
          { "id": "n5", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n3", "toPort": "a" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "b" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" },
          { "from": "n4", "fromPort": "out", "to": "n5", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:add",
        "node:multiply",
        "node:divide",
        "type:float"
      ],
      "examples": [
        "Subtract a center from UV.x or UV.y before Length or Distance for radial effects.",
        "Use (Noise − 0.5) to center a pattern around zero, then feed to Color Map.",
        "Combine with Absolute to get a distance-like value from a difference."
      ]
    },
    "node:multiply": {
      "title": "Multiply",
      "titleType": "node",
      "tagline": "Multiplies two numbers. Use it to scale a value (e.g. slow down or speed up time) or combine signals.",
      "description": "Multiply takes two inputs, a and b, and outputs a × b. If b is unconnected, the Multiplier parameter is used. Common use: connect Time to a and a small Float to b to slow down an animation, or connect Sine to a and a Float to b to change wave strength.",
      "inputs": [
        {
          "name": "a",
          "type": "float",
          "description": "First value. Often Time, Sine, or a pattern node’s output.",
          "suggestedSources": [
            "type:float",
            "node:constant-float",
            "node:time",
            "node:add",
            "node:sine",
            "node:uv-coordinates"
          ]
        },
        {
          "name": "b",
          "type": "float",
          "description": "Second value (multiplier). If unconnected, the Multiplier parameter is used.",
          "suggestedSources": [
            "type:float",
            "node:constant-float",
            "node:time",
            "node:add",
            "node:sine"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The product a × b. Connect to Add, Mix, Sine input, Color Map, or Output.",
          "suggestedTargets": [
            "node:add",
            "node:mix",
            "node:translate",
            "node:final-output",
            "node:color-map"
          ]
        }
      ],
      "parameters": [
        {
          "name": "Multiplier",
          "description": "Used for input b when nothing is connected. Set to 0.5 to halve the value (e.g. slow down time); set to 2 to double (e.g. brighter or faster)."
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "constant-float" },
          { "id": "n3", "type": "multiply" },
          { "id": "n4", "type": "color-map" },
          { "id": "n5", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n3", "toPort": "a" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "b" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" },
          { "from": "n4", "fromPort": "out", "to": "n5", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:add",
        "node:divide",
        "node:power",
        "type:float"
      ],
      "examples": [
        "Connect Time to a and a small constant to b (or Multiplier) to slow down animation.",
        "Multiply Sine by a float to change wave strength before Color Map.",
        "Scale a Noise or Distance value before feeding into Smoothstep or Color Map."
      ]
    },
    "node:divide": {
      "title": "Divide",
      "titleType": "node",
      "tagline": "Perfect for normalizing values and calculating ratios",
      "description": "Divides the first value by the second. Works with any numeric type through type promotion. Useful for normalization, calculating ratios, and inverting scales. Be careful to avoid division by zero. Connect Fragment Coords to a and Resolution to b for aspect-correct normalized coords; or connect Distance to a and a float to b for normalized falloff before Color Map.",
      "inputs": [
        {
          "name": "a",
          "type": "float",
          "description": "The dividend (value to be divided). Often Fragment Coords, Distance, or Length.",
          "suggestedSources": [
            "type:float",
            "node:constant-float",
            "node:fragment-coordinates",
            "node:resolution",
            "node:length",
            "node:distance"
          ]
        },
        {
          "name": "b",
          "type": "float",
          "description": "The divisor (value to divide by). Often Resolution or a constant for normalization.",
          "suggestedSources": [
            "type:float",
            "node:constant-float",
            "node:resolution",
            "node:length"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The quotient. Connect to Color Map, Multiply, or UV-style inputs for normalized values.",
          "suggestedTargets": [
            "node:multiply",
            "node:add",
            "node:uv-coordinates",
            "node:polar-coordinates"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "constant-float" },
          { "id": "n3", "type": "divide" },
          { "id": "n4", "type": "color-map" },
          { "id": "n5", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n3", "toPort": "a" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "b" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" },
          { "from": "n4", "fromPort": "out", "to": "n5", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:multiply",
        "node:reciprocal",
        "type:float"
      ]
    },
    "node:power": {
      "title": "Power",
      "titleType": "node",
      "tagline": "Ideal for exponential curves and non-linear transformations",
      "description": "Raises the base value to the power of the exponent. Useful for creating exponential curves, gamma corrections, and non-linear transformations. The exponent can be fractional for roots. Connect Smoothstep or Noise to base and a constant to exponent, then to Color Map for gamma-like falloff; or use exponent 0.5 for square-root style remapping.",
      "inputs": [
        {
          "name": "base",
          "type": "float",
          "description": "The base value to raise to a power. Often Smoothstep, Noise, or UV-derived value.",
          "suggestedSources": [
            "type:float",
            "node:constant-float",
            "node:add",
            "node:multiply",
            "node:smoothstep",
            "node:noise"
          ]
        },
        {
          "name": "exponent",
          "type": "float",
          "description": "The exponent to raise the base to. Use a constant (e.g. 2, 0.5) or connect a float.",
          "suggestedSources": [
            "type:float",
            "node:constant-float",
            "node:divide"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The result. Connect to Color Map, Mix, or Clamp for non-linear remapping.",
          "suggestedTargets": [
            "node:multiply",
            "node:mix",
            "node:color-map",
            "node:clamp"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "constant-float" },
          { "id": "n3", "type": "power" },
          { "id": "n4", "type": "color-map" },
          { "id": "n5", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n3", "toPort": "base" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "exponent" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" },
          { "from": "n4", "fromPort": "out", "to": "n5", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:square-root",
        "node:exponential",
        "type:float"
      ],
      "examples": [
        "Raise Smoothstep or Noise to an exponent for gamma-like falloff curves.",
        "Use base from UV or pattern and exponent 2 for quadratic falloff.",
        "Power of 0.5 is equivalent to Square Root for non-linear remapping."
      ],
      "advanced": "Fractional exponents give roots (e.g. 0.5 = square root). For e^x use Exponential; for arbitrary base use Power."
    },
    "node:square-root": {
      "title": "Square Root",
      "titleType": "node",
      "tagline": "Use this to calculate square roots and normalize distances",
      "description": "Calculates the square root of the input value. Commonly used for distance calculations, normalizing magnitudes, and creating smooth falloff curves. The square root is equivalent to raising a value to the power of 0.5. Connect Length or Distance output to in, then to Smoothstep or Color Map for soft falloff; or use after Dot Product for magnitude.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value to calculate the square root of. Often Length, Distance, or Dot Product output.",
          "suggestedSources": [
            "type:float",
            "node:length",
            "node:distance",
            "node:dot-product",
            "node:multiply"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The square root. Connect to Smoothstep, Mix, or Color Map for soft falloff.",
          "suggestedTargets": [
            "node:length",
            "node:normalize",
            "node:distance",
            "node:multiply",
            "node:mix"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "square-root" },
          { "id": "n3", "type": "color-map" },
          { "id": "n4", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n2", "toPort": "in" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "in" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:power",
        "node:length",
        "node:distance",
        "type:float"
      ],
      "examples": [
        "Feed Length or dot-product result into Square Root for magnitude before Smoothstep.",
        "Use after Distance for softer falloff in radial gradients.",
        "Normalize a squared value (e.g. from Dot Product) back to a length."
      ]
    },
    "node:absolute": {
      "title": "Absolute",
      "titleType": "node",
      "tagline": "Perfect for removing negative values and calculating magnitudes",
      "description": "Returns the absolute value of the input, removing any negative sign. Useful for distance calculations, ensuring positive values, and working with differences where direction doesn't matter. Connect (UV − 0.5) or (Noise − threshold) to get magnitude for falloff; feed Subtract output here when direction does not matter.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value. Often Subtract output, Sine, or Noise for magnitude-only use.",
          "suggestedSources": [
            "type:float",
            "node:subtract",
            "node:sine",
            "node:noise",
            "node:distance"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The absolute value (always positive or zero). Connect to Multiply, Mix, or Color Map.",
          "suggestedTargets": [
            "node:multiply",
            "node:mix",
            "node:length",
            "node:clamp"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "absolute" },
          { "id": "n3", "type": "color-map" },
          { "id": "n4", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n2", "toPort": "in" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "in" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:sign",
        "node:negate",
        "type:float"
      ],
      "examples": [
        "Use on (UV − 0.5) or (Noise − threshold) to get magnitude for falloff.",
        "Feed Subtract output into Absolute when direction does not matter.",
        "Combine with Distance for symmetric masks around a point."
      ]
    },
    "node:floor": {
      "title": "Floor",
      "titleType": "node",
      "tagline": "Ideal for rounding down to the nearest integer",
      "description": "Rounds the input value down to the nearest integer. Useful for creating discrete steps, grid-based effects, and quantizing values. Always rounds towards negative infinity. Connect UV × scale or Time to in for discrete cells or frame steps; use with Modulo for repeating tile indices in grids.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value to round down. Often UV × scale, Time, or Multiply output.",
          "suggestedSources": [
            "type:float",
            "node:constant-float",
            "node:multiply",
            "node:fract",
            "node:uv-coordinates"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The largest integer less than or equal to the input. Connect to Modulo, Color Map, or grid nodes.",
          "suggestedTargets": [
            "node:add",
            "node:multiply",
            "node:hexagonal-grid",
            "node:plane-grid",
            "node:modulo"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "floor" },
          { "id": "n3", "type": "color-map" },
          { "id": "n4", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n2", "toPort": "in" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "in" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:ceil",
        "node:round",
        "node:fract",
        "type:float"
      ],
      "examples": [
        "Floor(UV × scale) or Floor(Time) for discrete cells or frame steps.",
        "Use with Modulo for repeating tile indices in grids.",
        "Quantize a value before Color Map for stepped gradients."
      ]
    },
    "node:ceil": {
      "title": "Ceil",
      "titleType": "node",
      "tagline": "Use this to round up to the nearest integer",
      "description": "Rounds the input value up to the nearest integer. Useful for creating discrete steps, grid-based effects, and quantizing values. Always rounds towards positive infinity. Connect Multiply or Divide output to in for ceiling division; use with Modulo or grid nodes for tiling.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value to round up. Often Multiply, Divide, or UV-derived value.",
          "suggestedSources": [
            "type:float",
            "node:constant-float",
            "node:multiply",
            "node:fract",
            "node:divide"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The smallest integer ≥ input. Connect to Add, Multiply, Modulo, or grid nodes.",
          "suggestedTargets": [
            "node:add",
            "node:multiply",
            "node:hexagonal-grid",
            "node:modulo"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "ceil" },
          { "id": "n3", "type": "color-map" },
          { "id": "n4", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n2", "toPort": "in" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "in" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:floor",
        "node:round",
        "node:fract",
        "type:float"
      ]
    },
    "node:fract": {
      "title": "Fract",
      "titleType": "node",
      "tagline": "Perfect for extracting fractional parts and creating repeating patterns",
      "description": "Returns the fractional part of the input value (the part after the decimal point). Essential for creating repeating patterns, tiling effects, and extracting the decimal portion of values. The result is always between 0.0 and 1.0. Connect UV × scale or Time to in for repeating 0–1 pattern; feed output to Smoothstep, Rings, or Color Map for tiled effects.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value. Often UV × scale, Time, or Distance for repeating 0–1.",
          "suggestedSources": [
            "type:float",
            "node:multiply",
            "node:uv-coordinates",
            "node:time",
            "node:distance",
            "node:length"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The fractional part (0–1). Connect to Smoothstep, Rings, Color Map, or grid nodes.",
          "suggestedTargets": [
            "node:hexagonal-grid",
            "node:plane-grid",
            "node:rings",
            "node:smoothstep",
            "node:mix",
            "node:color-map"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "fract" },
          { "id": "n3", "type": "color-map" },
          { "id": "n4", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n2", "toPort": "in" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "in" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:floor",
        "node:ceil",
        "node:modulo",
        "type:float"
      ]
    },
    "node:modulo": {
      "title": "Modulo",
      "titleType": "node",
      "tagline": "Ideal for creating repeating cycles and wrapping values",
      "description": "Calculates the remainder after dividing the first value by the second. Essential for creating repeating patterns, wrapping values within a range, and implementing cyclic behaviors. The result is always between 0.0 and the divisor. Connect Time or UV × scale to a and a constant to b for repeating 0–1; feed output to Sine, Smoothstep, or Rings for cyclic effects.",
      "inputs": [
        {
          "name": "a",
          "type": "float",
          "description": "The dividend. Often Time, UV, or Multiply for wrapping.",
          "suggestedSources": [
            "type:float",
            "node:time",
            "node:uv-coordinates",
            "node:multiply",
            "node:add"
          ]
        },
        {
          "name": "b",
          "type": "float",
          "description": "The divisor. Usually a constant (e.g. 1 for 0–1 wrap).",
          "suggestedSources": [
            "type:float",
            "node:constant-float"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The remainder. Connect to Sine, Smoothstep, Rings, or Color Map for cycles.",
          "suggestedTargets": [
            "node:sine",
            "node:cosine",
            "node:fract",
            "node:smoothstep",
            "node:rings"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "constant-float" },
          { "id": "n3", "type": "modulo" },
          { "id": "n4", "type": "color-map" },
          { "id": "n5", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n3", "toPort": "a" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "b" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" },
          { "from": "n4", "fromPort": "out", "to": "n5", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:divide",
        "node:fract",
        "type:float"
      ]
    },
    "node:min": {
      "title": "Min",
      "titleType": "node",
      "tagline": "Use this to find the smaller of two values",
      "description": "Returns the minimum (smaller) of two input values. Useful for clamping values from above, finding the lower bound, and implementing conditional logic based on value comparisons. Connect a signal (e.g. Noise, distance) to a and an upper limit to b, then output to Color Map or Mix; often used with Max for soft clamping.",
      "inputs": [
        {
          "name": "a",
          "type": "float",
          "description": "The first value to compare",
          "suggestedSources": [
            "type:float",
            "node:constant-float",
            "node:add",
            "node:multiply",
            "node:smoothstep"
          ]
        },
        {
          "name": "b",
          "type": "float",
          "description": "The second value to compare",
          "suggestedSources": [
            "type:float",
            "node:constant-float",
            "node:add",
            "node:multiply"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The smaller of the two input values",
          "suggestedTargets": [
            "node:clamp",
            "node:mix",
            "node:max",
            "node:color-map"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "constant-float" },
          { "id": "n3", "type": "min" },
          { "id": "n4", "type": "color-map" },
          { "id": "n5", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n3", "toPort": "a" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "b" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" },
          { "from": "n4", "fromPort": "out", "to": "n5", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:max",
        "node:clamp",
        "type:float"
      ],
      "examples": [
        "Min(Noise, 1.0) or Min(distance, radius) to cap from above.",
        "Combine two signals and take the smaller for darken-style blending.",
        "Limit a value before feeding to Mix or Color Map."
      ]
    },
    "node:max": {
      "title": "Max",
      "titleType": "node",
      "tagline": "Perfect for finding the larger of two values",
      "description": "Returns the maximum (larger) of two input values. Useful for clamping values from below, finding the upper bound, and implementing conditional logic based on value comparisons. Connect a signal to a and a lower limit to b, then to Color Map or Mix; often used with Min for clamping to a range.",
      "inputs": [
        {
          "name": "a",
          "type": "float",
          "description": "The first value to compare",
          "suggestedSources": [
            "type:float",
            "node:constant-float",
            "node:add",
            "node:multiply",
            "node:sine"
          ]
        },
        {
          "name": "b",
          "type": "float",
          "description": "The second value to compare",
          "suggestedSources": [
            "type:float",
            "node:constant-float",
            "node:add",
            "node:multiply"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The larger of the two input values",
          "suggestedTargets": [
            "node:clamp",
            "node:mix",
            "node:min",
            "node:color-map"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "constant-float" },
          { "id": "n3", "type": "max" },
          { "id": "n4", "type": "color-map" },
          { "id": "n5", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n3", "toPort": "a" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "b" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" },
          { "from": "n4", "fromPort": "out", "to": "n5", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:min",
        "node:clamp",
        "type:float"
      ],
      "examples": [
        "Max(Noise, 0.0) or Max(distance − radius, 0) to clamp from below.",
        "Combine two signals and take the larger for lighten-style blending.",
        "Ensure a value is above a threshold before Smoothstep or Mix."
      ]
    },
    "node:clamp": {
      "title": "Clamp",
      "titleType": "node",
      "tagline": "Ideal for constraining values within a specific range",
      "description": "Clamps the input value between a minimum and maximum. If the value is below the minimum, it returns the minimum. If above the maximum, it returns the maximum. Otherwise, it returns the original value. Essential for keeping values within valid ranges. Connect Noise, Distance, or Sine to in and set min/max (or connect Float nodes), then to Color Map or Mix; often used after Smoothstep or Add to keep result in 0–1.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value to clamp",
          "suggestedSources": [
            "type:float",
            "node:add",
            "node:multiply",
            "node:sine",
            "node:noise"
          ]
        },
        {
          "name": "min",
          "type": "float",
          "description": "The minimum allowed value",
          "suggestedSources": [
            "type:float",
            "node:constant-float"
          ]
        },
        {
          "name": "max",
          "type": "float",
          "description": "The maximum allowed value",
          "suggestedSources": [
            "type:float",
            "node:constant-float"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The clamped value (between min and max)",
          "suggestedTargets": [
            "node:mix",
            "node:color-map",
            "node:final-output",
            "node:smoothstep"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "constant-float" },
          { "id": "n3", "type": "constant-float" },
          { "id": "n4", "type": "clamp" },
          { "id": "n5", "type": "color-map" },
          { "id": "n6", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n4", "toPort": "in" },
          { "from": "n2", "fromPort": "out", "to": "n4", "toPort": "min" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "max" },
          { "from": "n4", "fromPort": "out", "to": "n5", "toPort": "in" },
          { "from": "n5", "fromPort": "out", "to": "n6", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:min",
        "node:max",
        "node:clamp-01",
        "node:saturate",
        "type:float"
      ]
    },
    "node:mix": {
      "title": "Mix",
      "titleType": "node",
      "tagline": "Blends two values by a factor: 0 = first, 1 = second. Use for crossfades, masks, and smooth transitions.",
      "description": "Performs linear interpolation between two values based on a blend factor. When the blend factor is 0.0, it returns the first value. When it's 1.0, it returns the second value. Values in between are linearly interpolated. Connect two values (e.g. two Noise outputs or two colors) and a factor t (e.g. Smoothstep or UV.x); often used with Color Map and Output for blended patterns. Works with any numeric type.",
      "inputs": [
        {
          "name": "a",
          "type": "float",
          "description": "The first value (returned when t = 0.0)",
          "suggestedSources": [
            "type:float",
            "node:constant-float",
            "node:sine",
            "node:add",
            "node:noise"
          ]
        },
        {
          "name": "b",
          "type": "float",
          "description": "The second value (returned when t = 1.0)",
          "suggestedSources": [
            "type:float",
            "node:constant-float",
            "node:sine",
            "node:add",
            "node:noise"
          ]
        },
        {
          "name": "t",
          "type": "float",
          "description": "The blend factor (typically 0.0 to 1.0)",
          "suggestedSources": [
            "type:float",
            "node:constant-float",
            "node:smoothstep",
            "node:uv-coordinates"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The interpolated value between a and b",
          "suggestedTargets": [
            "node:final-output",
            "node:color-map",
            "node:blend-mode",
            "node:translate",
            "node:scale"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "constant-float" },
          { "id": "n3", "type": "constant-float" },
          { "id": "n4", "type": "mix" },
          { "id": "n5", "type": "color-map" },
          { "id": "n6", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n4", "toPort": "a" },
          { "from": "n2", "fromPort": "out", "to": "n4", "toPort": "b" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "t" },
          { "from": "n4", "fromPort": "out", "to": "n5", "toPort": "in" },
          { "from": "n5", "fromPort": "out", "to": "n6", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:lerp",
        "node:smoothstep",
        "type:float"
      ],
      "examples": [
        "Connect two Noise (or Sine) outputs to a and b, and Smoothstep to t for a blended mask.",
        "Crossfade two patterns: one to a, one to b, and a 0–1 factor to t.",
        "Use with Color Map: mix two float sources and feed the result to Color Map, then Output."
      ]
    },
    "node:step": {
      "title": "Step",
      "titleType": "node",
      "tagline": "Use this to create hard thresholds and binary decisions",
      "description": "Returns 0.0 if the input value is less than the edge value, otherwise returns 1.0. Creates a hard step function that's useful for creating binary masks, thresholds, and on/off switches based on value comparisons.",
      "inputs": [
        {
          "name": "edge",
          "type": "float",
          "description": "The threshold value to compare against",
          "suggestedSources": [
            "type:float",
            "node:constant-float",
            "node:smoothstep"
          ]
        },
        {
          "name": "x",
          "type": "float",
          "description": "The value to compare with the edge",
          "suggestedSources": [
            "type:float",
            "node:noise",
            "node:distance",
            "node:sine",
            "node:uv-coordinates"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "0.0 if x < edge, 1.0 otherwise",
          "suggestedTargets": [
            "node:mix",
            "node:select",
            "node:compare",
            "node:gradient-mask",
            "node:oklch-color-map-threshold"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "constant-float" },
          { "id": "n3", "type": "step" },
          { "id": "n4", "type": "color-map" },
          { "id": "n5", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n3", "toPort": "edge" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "x" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" },
          { "from": "n4", "fromPort": "out", "to": "n5", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:smoothstep",
        "node:compare",
        "type:float"
      ],
      "examples": [
        "Step(threshold, Noise) for a hard cut between two regions.",
        "Create a binary mask from Distance or Length for sharp edges.",
        "Use output as condition for Select or as mask for Mix."
      ],
      "advanced": "Step gives a hard 0/1 boundary; use Smoothstep when you want a smooth transition between two edges."
    },
    "node:smoothstep": {
      "title": "Smoothstep",
      "titleType": "node",
      "tagline": "Ideal for creating smooth transitions with ease-in-out curves",
      "description": "Performs smooth Hermite interpolation between two edge values. Returns 0.0 if the input is below edge0, 1.0 if above edge1, and smoothly interpolates between them. Creates an S-curve that's perfect for smooth transitions, fades, and easing functions.",
      "inputs": [
        {
          "name": "edge0",
          "type": "float",
          "description": "The lower edge of the transition (returns 0.0 below this)",
          "suggestedSources": [
            "type:float",
            "node:constant-float"
          ]
        },
        {
          "name": "edge1",
          "type": "float",
          "description": "The upper edge of the transition (returns 1.0 above this)",
          "suggestedSources": [
            "type:float",
            "node:constant-float"
          ]
        },
        {
          "name": "x",
          "type": "float",
          "description": "The input value to evaluate",
          "suggestedSources": [
            "type:float",
            "node:noise",
            "node:distance",
            "node:sine",
            "node:uv-coordinates",
            "node:fract"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "Smoothly interpolated value between 0.0 and 1.0",
          "suggestedTargets": [
            "node:mix",
            "node:color-map",
            "node:gradient-mask",
            "node:twist-distortion",
            "node:translate"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "constant-float" },
          { "id": "n3", "type": "constant-float" },
          { "id": "n4", "type": "smoothstep" },
          { "id": "n5", "type": "color-map" },
          { "id": "n6", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n4", "toPort": "edge0" },
          { "from": "n2", "fromPort": "out", "to": "n4", "toPort": "edge1" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "x" },
          { "from": "n4", "fromPort": "out", "to": "n5", "toPort": "in" },
          { "from": "n5", "fromPort": "out", "to": "n6", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:step",
        "node:mix",
        "node:lerp",
        "type:float"
      ]
    },
    "node:sine": {
      "title": "Sine",
      "titleType": "node",
      "tagline": "Perfect for creating oscillating waves and periodic animations",
      "description": "Calculates the sine of the input angle (in radians). Returns values between -1.0 and 1.0, creating a smooth oscillating wave. Essential for creating periodic animations, waves, circular motion, and oscillating effects.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The angle in radians",
          "suggestedSources": [
            "type:float",
            "node:time",
            "node:multiply",
            "node:constant-float",
            "node:uv-coordinates"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The sine value (between -1.0 and 1.0)",
          "suggestedTargets": [
            "node:add",
            "node:multiply",
            "node:mix",
            "node:wave-patterns",
            "node:translate",
            "node:rotate"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "time" },
          { "id": "n2", "type": "sine" },
          { "id": "n3", "type": "color-map" },
          { "id": "n4", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n2", "toPort": "in" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "in" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:cosine",
        "node:tangent",
        "node:time",
        "type:float"
      ]
    },
    "node:cosine": {
      "title": "Cosine",
      "titleType": "node",
      "tagline": "Use this for oscillating waves with a phase offset",
      "description": "Calculates the cosine of the input angle (in radians). Returns values between -1.0 and 1.0, creating a smooth oscillating wave that's phase-shifted by 90 degrees from sine. Useful for circular motion, rotations, and periodic effects.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The angle in radians",
          "suggestedSources": [
            "type:float",
            "node:time",
            "node:multiply",
            "node:constant-float",
            "node:arc-tangent-2",
            "node:uv-coordinates"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The cosine value (between -1.0 and 1.0)",
          "suggestedTargets": [
            "node:add",
            "node:multiply",
            "node:mix",
            "node:wave-patterns",
            "node:rotate",
            "node:vector-field"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "time" },
          { "id": "n2", "type": "cosine" },
          { "id": "n3", "type": "color-map" },
          { "id": "n4", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n2", "toPort": "in" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "in" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:sine",
        "node:tangent",
        "node:time",
        "type:float"
      ]
    },
    "node:tangent": {
      "title": "Tangent",
      "titleType": "node",
      "tagline": "Ideal for calculating slopes and ratios in trigonometry",
      "description": "Calculates the tangent of the input angle (in radians). The tangent is the ratio of sine to cosine. Returns values from negative to positive infinity, with discontinuities at odd multiples of π/2. Useful for advanced trigonometric calculations.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The angle in radians",
          "suggestedSources": [
            "type:float",
            "node:time",
            "node:arc-tangent-2",
            "node:constant-float",
            "node:uv-coordinates"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The tangent value",
          "suggestedTargets": [
            "node:arc-tangent",
            "node:multiply",
            "node:add",
            "node:mix"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "time" },
          { "id": "n2", "type": "tangent" },
          { "id": "n3", "type": "color-map" },
          { "id": "n4", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n2", "toPort": "in" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "in" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:sine",
        "node:cosine",
        "node:arc-tangent",
        "type:float"
      ],
      "examples": [
        "Tangent(Time) for sharp periodic peaks (clamp input to avoid discontinuities).",
        "Use with Arc Tangent for angle recovery from slope ratios.",
        "Feed normalized angles for repeating saw-like or spike patterns."
      ],
      "advanced": "Tangent has discontinuities at ±π/2; clamp input or use modulo to stay within a safe range. Prefer Sine/Cosine for smooth waves."
    },
    "node:arc-sine": {
      "title": "Arc Sine",
      "titleType": "node",
      "tagline": "Perfect for converting sine values back to angles",
      "description": "Calculates the inverse sine (arcsine) of the input value. Returns an angle in radians between -π/2 and π/2. The input must be between -1.0 and 1.0. Useful for converting sine values back to angles and solving trigonometric equations.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The sine value (must be between -1.0 and 1.0)",
          "suggestedSources": [
            "type:float",
            "node:sine",
            "node:cosine",
            "node:clamp",
            "node:mix"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The angle in radians (between -π/2 and π/2)",
          "suggestedTargets": [
            "node:sine",
            "node:cosine",
            "node:rotate",
            "node:multiply"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "arc-sine" },
          { "id": "n3", "type": "color-map" },
          { "id": "n4", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n2", "toPort": "in" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "in" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:sine",
        "node:arc-cosine",
        "node:arc-tangent",
        "type:float"
      ]
    },
    "node:arc-cosine": {
      "title": "Arc Cosine",
      "titleType": "node",
      "tagline": "Use this to convert cosine values back to angles",
      "description": "Calculates the inverse cosine (arccosine) of the input value. Returns an angle in radians between 0.0 and π. The input must be between -1.0 and 1.0. Useful for converting cosine values back to angles and solving trigonometric equations.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The cosine value (must be between -1.0 and 1.0)",
          "suggestedSources": [
            "type:float",
            "node:sine",
            "node:cosine",
            "node:dot-product",
            "node:clamp"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The angle in radians (between 0.0 and π)",
          "suggestedTargets": [
            "node:sine",
            "node:cosine",
            "node:rotate",
            "node:multiply"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "arc-cosine" },
          { "id": "n3", "type": "color-map" },
          { "id": "n4", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n2", "toPort": "in" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "in" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:cosine",
        "node:arc-sine",
        "node:arc-tangent",
        "type:float"
      ]
    },
    "node:arc-tangent": {
      "title": "Arc Tangent",
      "titleType": "node",
      "tagline": "Ideal for converting tangent values to angles",
      "description": "Calculates the inverse tangent (arctangent) of the input value. Returns an angle in radians between -π/2 and π/2. Useful for converting slopes and ratios back to angles, but limited to two quadrants. For full 360-degree coverage, use Arc Tangent 2.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The tangent value (ratio)",
          "suggestedSources": [
            "type:float",
            "node:tangent",
            "node:divide",
            "node:constant-float"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The angle in radians (between -π/2 and π/2)",
          "suggestedTargets": [
            "node:sine",
            "node:cosine",
            "node:rotate",
            "node:multiply"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "arc-tangent" },
          { "id": "n3", "type": "color-map" },
          { "id": "n4", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n2", "toPort": "in" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "in" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:tangent",
        "node:arc-tangent-2",
        "type:float"
      ]
    },
    "node:arc-tangent-2": {
      "title": "Arc Tangent 2",
      "titleType": "node",
      "tagline": "Perfect for converting coordinates to angles with full quadrant support",
      "description": "Calculates the angle from the x-axis to a point given by (x, y) coordinates. Returns an angle in radians between -π and π, covering all four quadrants. Essential for converting 2D coordinates to angles, calculating directions, and working with polar coordinates.",
      "inputs": [
        {
          "name": "y",
          "type": "float",
          "description": "The y-coordinate of the point",
          "suggestedSources": [
            "type:float",
            "node:split-vector",
            "node:uv-coordinates",
            "node:polar-coordinates",
            "node:constant-float"
          ]
        },
        {
          "name": "x",
          "type": "float",
          "description": "The x-coordinate of the point",
          "suggestedSources": [
            "type:float",
            "node:split-vector",
            "node:uv-coordinates",
            "node:polar-coordinates",
            "node:constant-float"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The angle in radians (between -π and π)",
          "suggestedTargets": [
            "node:rotate",
            "node:sine",
            "node:cosine",
            "node:kaleidoscope",
            "node:polar-coordinates"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "constant-float" },
          { "id": "n3", "type": "arc-tangent-2" },
          { "id": "n4", "type": "color-map" },
          { "id": "n5", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n3", "toPort": "y" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "x" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" },
          { "from": "n4", "fromPort": "out", "to": "n5", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:arc-tangent",
        "node:rotate",
        "type:float",
        "type:vec2"
      ]
    },
    "node:exponential": {
      "title": "Exponential",
      "titleType": "node",
      "tagline": "Use this for exponential growth and decay curves",
      "description": "Calculates e (Euler's number, approximately 2.718) raised to the power of the input. Creates exponential growth curves when the input is positive and exponential decay when negative. Useful for natural growth/decay effects, logarithmic scales, and advanced mathematical operations.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The exponent to raise e to",
          "suggestedSources": [
            "type:float",
            "node:time",
            "node:multiply",
            "node:natural-logarithm",
            "node:sine"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "e raised to the power of the input",
          "suggestedTargets": [
            "node:natural-logarithm",
            "node:multiply",
            "node:mix",
            "node:color-map"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "exponential" },
          { "id": "n3", "type": "color-map" },
          { "id": "n4", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n2", "toPort": "in" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "in" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:natural-logarithm",
        "node:power",
        "type:float"
      ]
    },
    "node:natural-logarithm": {
      "title": "Natural Logarithm",
      "titleType": "node",
      "tagline": "Ideal for inverting exponential functions and logarithmic scales",
      "description": "Calculates the natural logarithm (base e) of the input value. The input must be greater than zero. This is the inverse of the exponential function. Useful for compressing large value ranges, inverting exponential curves, and working with logarithmic scales.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value to calculate the logarithm of (must be > 0)",
          "suggestedSources": [
            "type:float",
            "node:exponential",
            "node:distance",
            "node:length",
            "node:add"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The natural logarithm of the input",
          "suggestedTargets": [
            "node:exponential",
            "node:multiply",
            "node:power"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "natural-logarithm" },
          { "id": "n3", "type": "color-map" },
          { "id": "n4", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n2", "toPort": "in" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "in" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:exponential",
        "node:power",
        "type:float"
      ]
    },
    "node:length": {
      "title": "Length",
      "titleType": "node",
      "tagline": "Perfect for calculating vector magnitudes and distances from origin",
      "description": "Calculates the length (magnitude) of a vector. For a 2D vector, this is the distance from the origin (0,0) to the point. Essential for distance calculations, normalizing vectors, and working with vector magnitudes. Connect UV or Translate output to in, then to Smoothstep or Color Map for radial falloff from center; often used with Distance and Square Root for magnitude-based effects.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The vector. Often UV, Translate output, or position for radial falloff.",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:polar-coordinates",
            "node:constant-vec2"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "Magnitude (length). Connect to Smoothstep, Color Map, or Square Root for falloff.",
          "suggestedTargets": [
            "node:normalize",
            "node:distance",
            "node:smoothstep",
            "node:rings",
            "node:gradient-mask"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "uv-coordinates" },
          { "id": "n2", "type": "length" },
          { "id": "n3", "type": "color-map" },
          { "id": "n4", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n2", "toPort": "in" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "in" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:distance",
        "node:normalize",
        "node:square-root",
        "type:vec2"
      ]
    },
    "node:distance": {
      "title": "Distance",
      "titleType": "node",
      "tagline": "Use this to calculate the distance between two points",
      "description": "Calculates the Euclidean distance between two points. Returns the length of the vector from point a to point b. Essential for proximity-based effects, radial gradients, and spatial calculations. Connect UV to a and Constant Vec2 (e.g. 0.5, 0.5) to b, then output to Smoothstep or Color Map for radial falloff; often used with Length and Normalize for direction-based effects.",
      "inputs": [
        {
          "name": "a",
          "type": "vec2",
          "description": "The first point. Often UV, Translate output, or center.",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:constant-vec2"
          ]
        },
        {
          "name": "b",
          "type": "vec2",
          "description": "The second point. Often Constant Vec2 (center) or another UV/position.",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:constant-vec2",
            "node:translate"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "Distance between a and b. Connect to Smoothstep, Color Map, or Rings for radial effects.",
          "suggestedTargets": [
            "node:smoothstep",
            "node:gradient-mask",
            "node:rings",
            "node:voronoi-noise",
            "node:sphere-raymarch"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "uv-coordinates" },
          { "id": "n2", "type": "constant-vec2" },
          { "id": "n3", "type": "distance" },
          { "id": "n4", "type": "color-map" },
          { "id": "n5", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n3", "toPort": "a" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "b" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" },
          { "from": "n4", "fromPort": "out", "to": "n5", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:length",
        "node:normalize",
        "type:vec2"
      ]
    },
    "node:dot-product": {
      "title": "Dot Product",
      "titleType": "node",
      "tagline": "Ideal for calculating angles, projections, and lighting",
      "description": "Calculates the dot product of two vectors. Returns a scalar value that represents the cosine of the angle between vectors (when normalized) multiplied by their lengths. Essential for lighting calculations, angle measurements, and vector projections. Connect Normalize(UV) to a and a direction (e.g. Constant Vec2) to b, then to Color Map or Lighting Shading; often used with Normalize for lighting and reflections.",
      "inputs": [
        {
          "name": "a",
          "type": "vec2",
          "description": "The first vector. Often Normalize(UV) or a direction from a node.",
          "suggestedSources": [
            "type:vec2",
            "node:normalize",
            "node:uv-coordinates",
            "node:lighting-shading",
            "node:constant-vec2"
          ]
        },
        {
          "name": "b",
          "type": "vec2",
          "description": "The second vector. Often Normalize output, Normal Mapping, or Constant Vec2.",
          "suggestedSources": [
            "type:vec2",
            "node:normalize",
            "node:normal-mapping",
            "node:constant-vec2"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "Dot product (scalar). Connect to Lighting Shading, Mix, Smoothstep, or Color Map.",
          "suggestedTargets": [
            "node:lighting-shading",
            "node:mix",
            "node:smoothstep",
            "node:color-map",
            "node:vector-field"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "uv-coordinates" },
          { "id": "n2", "type": "constant-vec2" },
          { "id": "n3", "type": "dot-product" },
          { "id": "n4", "type": "color-map" },
          { "id": "n5", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n3", "toPort": "a" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "b" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" },
          { "from": "n4", "fromPort": "out", "to": "n5", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:cross-product",
        "node:normalize",
        "type:vec2"
      ]
    },
    "node:cross-product": {
      "title": "Cross Product",
      "titleType": "node",
      "tagline": "Perfect for calculating perpendicular vectors and surface normals",
      "description": "Calculates the cross product of two 3D vectors. Returns a vector perpendicular to both input vectors, with magnitude equal to the area of the parallelogram they form. Essential for calculating surface normals, determining orientation, and 3D vector mathematics. Connect two tangent or edge vectors to a and b, then output to Normalize for a surface normal; often used with Normal Mapping and Lighting Shading in 3D.",
      "inputs": [
        {
          "name": "a",
          "type": "vec3",
          "description": "The first 3D vector. Often Normalize or Normal Mapping output.",
          "suggestedSources": [
            "type:vec3",
            "node:normalize",
            "node:normal-mapping",
            "node:constant-vec3"
          ]
        },
        {
          "name": "b",
          "type": "vec3",
          "description": "The second 3D vector. Often Normalize or Normal Mapping output.",
          "suggestedSources": [
            "type:vec3",
            "node:normalize",
            "node:normal-mapping",
            "node:constant-vec3"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec3",
          "description": "Cross product (perpendicular vector). Connect to Normalize, Normal Mapping, or Lighting Shading.",
          "suggestedTargets": [
            "node:normalize",
            "node:normal-mapping",
            "node:lighting-shading"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-vec3" },
          { "id": "n2", "type": "constant-vec3" },
          { "id": "n3", "type": "cross-product" },
          { "id": "n4", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n3", "toPort": "a" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "b" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:dot-product",
        "node:normalize",
        "type:vec3"
      ]
    },
    "node:normalize": {
      "title": "Normalize",
      "titleType": "node",
      "tagline": "Use this to create unit vectors with length 1.0",
      "description": "Normalizes a vector to unit length (magnitude of 1.0) while preserving its direction. The result points in the same direction as the input but has a length of exactly 1.0. Essential for direction vectors, normals, and any calculations requiring unit vectors. Connect UV or a direction to in, then output to Dot Product or Reflect for lighting/reflections; often used with Length and Distance for direction-only math.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The vector to normalize. Often UV, Translate output, or polar/position vector.",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:polar-coordinates",
            "node:distance"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "Unit vector (length 1). Connect to Dot Product, Reflect, Refract, or Lighting Shading.",
          "suggestedTargets": [
            "node:dot-product",
            "node:reflect",
            "node:refract",
            "node:vector-field",
            "node:lighting-shading"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "uv-coordinates" },
          { "id": "n2", "type": "normalize" },
          { "id": "n3", "type": "constant-vec2" },
          { "id": "n4", "type": "dot-product" },
          { "id": "n5", "type": "color-map" },
          { "id": "n6", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n2", "toPort": "in" },
          { "from": "n2", "fromPort": "out", "to": "n4", "toPort": "a" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "b" },
          { "from": "n4", "fromPort": "out", "to": "n5", "toPort": "in" },
          { "from": "n5", "fromPort": "out", "to": "n6", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:length",
        "node:distance",
        "node:dot-product",
        "type:vec2"
      ]
    },
    "node:reflect": {
      "title": "Reflect",
      "titleType": "node",
      "tagline": "Ideal for calculating reflection vectors for lighting and mirrors",
      "description": "Calculates the reflection of an incident vector off a surface with a given normal. The result is the direction the vector would bounce after hitting the surface. Essential for specular reflections, mirror effects, and physically-based lighting calculations. Connect view or light direction to I and surface normal to N, then output to Dot Product or Lighting Shading for specular; often used with Normalize.",
      "inputs": [
        {
          "name": "I",
          "type": "vec2",
          "description": "Incident direction. Often Normalize(UV) or view/light direction.",
          "suggestedSources": [
            "type:vec2",
            "node:normalize",
            "node:uv-coordinates",
            "node:normal-mapping"
          ]
        },
        {
          "name": "N",
          "type": "vec2",
          "description": "Surface normal (normalized). Often from Normal Mapping or Constant Vec2.",
          "suggestedSources": [
            "type:vec2",
            "node:normalize",
            "node:normal-mapping",
            "node:constant-vec2"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "Reflected direction. Connect to Dot Product or Lighting Shading for specular.",
          "suggestedTargets": [
            "node:dot-product",
            "node:lighting-shading",
            "node:normalize"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "uv-coordinates" },
          { "id": "n2", "type": "constant-vec2" },
          { "id": "n3", "type": "reflect" },
          { "id": "n4", "type": "length" },
          { "id": "n5", "type": "color-map" },
          { "id": "n6", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n3", "toPort": "I" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "N" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" },
          { "from": "n4", "fromPort": "out", "to": "n5", "toPort": "in" },
          { "from": "n5", "fromPort": "out", "to": "n6", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:refract",
        "node:normalize",
        "node:dot-product",
        "type:vec2"
      ]
    },
    "node:refract": {
      "title": "Refract",
      "titleType": "node",
      "tagline": "Perfect for calculating refraction through transparent materials",
      "description": "Calculates the refracted vector when light passes through a surface with different indices of refraction. The eta parameter is the ratio of the first medium's index to the second medium's index. Essential for realistic glass, water, and transparent material effects. Connect view direction to I, surface normal to N, and ratio (e.g. 0.75 for air/glass) to eta; output to Dot Product or Lighting Shading for refraction. Often used with Normalize.",
      "inputs": [
        {
          "name": "I",
          "type": "vec2",
          "description": "Incident direction (entering surface). Often Normalize(UV) or view direction.",
          "suggestedSources": [
            "type:vec2",
            "node:normalize",
            "node:uv-coordinates",
            "node:normal-mapping"
          ]
        },
        {
          "name": "N",
          "type": "vec2",
          "description": "Surface normal (normalized). Often from Normal Mapping or Constant Vec2.",
          "suggestedSources": [
            "type:vec2",
            "node:normalize",
            "node:normal-mapping",
            "node:constant-vec2"
          ]
        },
        {
          "name": "eta",
          "type": "float",
          "description": "Ratio n1/n2 (e.g. 0.75 for air→glass). Connect Constant Float or Divide.",
          "suggestedSources": [
            "type:float",
            "node:constant-float",
            "node:divide"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "Refracted direction. Connect to Normalize, Dot Product, or Lighting Shading.",
          "suggestedTargets": [
            "node:normalize",
            "node:dot-product",
            "node:lighting-shading"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "uv-coordinates" },
          { "id": "n2", "type": "constant-vec2" },
          { "id": "n3", "type": "constant-float" },
          { "id": "n4", "type": "refract" },
          { "id": "n5", "type": "length" },
          { "id": "n6", "type": "color-map" },
          { "id": "n7", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n4", "toPort": "I" },
          { "from": "n2", "fromPort": "out", "to": "n4", "toPort": "N" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "eta" },
          { "from": "n4", "fromPort": "out", "to": "n5", "toPort": "in" },
          { "from": "n5", "fromPort": "out", "to": "n6", "toPort": "in" },
          { "from": "n6", "fromPort": "out", "to": "n7", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:reflect",
        "node:normalize",
        "type:vec2"
      ]
    },
    "node:blend-mode": {
      "title": "Blend Mode",
      "titleType": "node",
      "tagline": "Ideal for combining two values using various blend modes like multiply, screen, overlay, and more",
      "description": "Applies one of 12 different blending modes to combine a base value with a blend value. The blend modes include Normal (pass-through), Multiply, Screen, Overlay, Soft Light, Hard Light, Color Dodge, Color Burn, Linear Dodge (Add), Linear Burn, Difference, and Exclusion. Each mode produces a different visual effect when combining values. The opacity parameter controls how much of the blended result is mixed with the original base value, allowing for partial blending effects.",
      "inputs": [
        {
          "name": "base",
          "type": "float",
          "description": "The base value that will be blended with the blend input",
          "suggestedSources": [
            "type:float",
            "node:color-map",
            "node:oklch-color-map-bezier",
            "node:mix",
            "node:uv-coordinates"
          ]
        },
        {
          "name": "blend",
          "type": "float",
          "description": "The value to blend with the base using the selected blend mode",
          "suggestedSources": [
            "type:float",
            "node:color-map",
            "node:noise",
            "node:mix",
            "node:gradient-mask"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The result of blending the base and blend inputs using the selected mode, mixed with the base according to the opacity parameter",
          "suggestedTargets": [
            "node:final-output",
            "node:mix",
            "node:color-grading"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "constant-float" },
          { "id": "n3", "type": "blend-mode" },
          { "id": "n4", "type": "color-map" },
          { "id": "n5", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n3", "toPort": "base" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "blend" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" },
          { "from": "n4", "fromPort": "out", "to": "n5", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "type:float",
        "node:mix",
        "node:lerp"
      ]
    },
    "node:oklch-color-map-bezier": {
      "title": "Color Map Smooth",
      "titleType": "node",
      "tagline": "Perfect for converting float values to RGB colors using OKLCH color space with smooth bezier curve interpolation",
      "description": "Converts a float value (0-1) to an RGB color using the OKLCH color space with cubic bezier curve interpolation. This node provides smooth, customizable color transitions by allowing independent bezier curves for Lightness (L), Chroma (C), and Hue (H) components. The bezier curves control how each color component transitions from the start color to the end color, enabling complex color gradients with precise control over the interpolation curves. The result is converted from OKLCH to RGB for display.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The input value (0-1) to map to a color"
        },
        {
          "name": "startColor",
          "type": "vec3",
          "description": "The starting OKLCH color (L, C, H components)"
        },
        {
          "name": "endColor",
          "type": "vec3",
          "description": "The ending OKLCH color (L, C, H components)"
        },
        {
          "name": "lCurve",
          "type": "vec4",
          "description": "Cubic bezier control points for Lightness interpolation (x1, y1, x2, y2)"
        },
        {
          "name": "cCurve",
          "type": "vec4",
          "description": "Cubic bezier control points for Chroma interpolation (x1, y1, x2, y2)"
        },
        {
          "name": "hCurve",
          "type": "vec4",
          "description": "Cubic bezier control points for Hue interpolation (x1, y1, x2, y2)"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec3",
          "description": "The resulting RGB color converted from OKLCH"
        }
      ],
      "relatedItems": [
        "node:oklch-color-map-threshold",
        "node:color-map",
        "node:oklch-color",
        "type:float",
        "type:vec3"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "noise" },
          { "id": "c", "type": "oklch-color-map-bezier" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      }
    },
    "node:oklch-color-map-threshold": {
      "title": "Color Map Stepped",
      "titleType": "node",
      "tagline": "Ideal for creating color gradients with discrete color stops and optional dithering using OKLCH color space",
      "description": "Converts a float value (0-1) to an RGB color using the OKLCH color space with threshold-based color stops. This mode creates discrete color bands with configurable transition widths between stops, allowing for stepped gradients or posterized color effects. Optional Bayer dithering can be applied to reduce banding artifacts. The node generates color stops on-the-fly based on the stops parameter, interpolating between start and end colors using bezier curves for L, C, and H components. The result is converted from OKLCH to RGB for display.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The input value (0-1) to map to a color"
        },
        {
          "name": "startColor",
          "type": "vec3",
          "description": "The starting OKLCH color (L, C, H components)"
        },
        {
          "name": "endColor",
          "type": "vec3",
          "description": "The ending OKLCH color (L, C, H components)"
        },
        {
          "name": "lCurve",
          "type": "vec4",
          "description": "Cubic bezier control points for Lightness interpolation (x1, y1, x2, y2)"
        },
        {
          "name": "cCurve",
          "type": "vec4",
          "description": "Cubic bezier control points for Chroma interpolation (x1, y1, x2, y2)"
        },
        {
          "name": "hCurve",
          "type": "vec4",
          "description": "Cubic bezier control points for Hue interpolation (x1, y1, x2, y2)"
        },
        {
          "name": "fragCoord",
          "type": "vec2",
          "description": "Fragment coordinates for dithering calculations"
        },
        {
          "name": "resolution",
          "type": "vec2",
          "description": "Screen resolution for dithering calculations"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec3",
          "description": "The resulting RGB color converted from OKLCH with optional dithering applied"
        }
      ],
      "relatedItems": [
        "node:oklch-color-map-bezier",
        "node:color-map",
        "node:bayer-dither",
        "node:oklch-color",
        "type:float",
        "type:vec3"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "noise" },
          { "id": "c", "type": "oklch-color-map-threshold" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "examples": [
        "Feed Noise or Smoothstep into Color Map Stepped for discrete color bands or posterized gradients.",
        "Enable dithering and connect Frag Coord and Resolution to reduce banding in gradients.",
        "Chain: pattern → Color Map Stepped → Glow or Color Grading for stylized color looks."
      ],
      "advanced": "Threshold mode creates discrete stops; use the stops parameter to control how many bands. Connect Bayer Dither upstream or use the node's built-in dither option to reduce banding on limited color depth."
    },
    "node:color-map": {
      "title": "Color Map",
      "titleType": "node",
      "tagline": "Turns a single number (float) into a grayscale color so you can send it to the Output and see it on screen.",
      "description": "Color Map takes one number (a float, usually between 0 and 1) and turns it into a grayscale color: 0 = black, 1 = white, values in between = gray. The Output node expects a color (vec3), so you need Color Map (or another color node) between a float pattern and the Output.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "A number (0–1 works best). Connect Noise, Sine, Smoothstep, or any float output.",
          "suggestedSources": [
            "type:float",
            "node:noise",
            "node:smoothstep",
            "node:sine",
            "node:distance"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec3",
          "description": "Grayscale color. Connect this to Output, or to Mix/Blend for more effects.",
          "suggestedTargets": [
            "node:final-output",
            "node:mix",
            "node:blend-mode",
            "node:tone-mapping",
            "node:glow-bloom"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          {
            "id": "a",
            "type": "uv-coordinates"
          },
          {
            "id": "b",
            "type": "noise"
          },
          {
            "id": "c",
            "type": "color-map"
          },
          {
            "id": "d",
            "type": "final-output"
          }
        ],
        "connections": [
          {
            "from": "a",
            "fromPort": "out",
            "to": "b",
            "toPort": "in"
          },
          {
            "from": "b",
            "fromPort": "out",
            "to": "c",
            "toPort": "in"
          },
          {
            "from": "c",
            "fromPort": "out",
            "to": "d",
            "toPort": "in"
          }
        ]
      },
      "relatedItems": [
        "node:oklch-color-map-bezier",
        "node:oklch-color-map-threshold",
        "type:float",
        "type:vec3"
      ],
      "examples": [
        "Connect Noise (or any float) to Color Map, then Color Map to Output to see a grayscale pattern.",
        "Chain: UV → Noise → Color Map → Output for a quick on-screen pattern.",
        "Feed Color Map output into Mix, Blend, or Glow for further effects before Output."
      ],
      "advanced": "Use Color Map for simple grayscale (one float → gray). Use OKLCH Color Map Smooth or Stepped when you need hue and saturation control, or when you want smooth bezier curves or discrete color bands with optional dithering."
    },
    "node:glow-bloom": {
      "title": "Glow",
      "titleType": "node",
      "tagline": "Adds edge glow and bloom: bright areas above a threshold get a soft halo. Connect color into in, then to Output or more post-process.",
      "description": "Adds edge glow and bloom effects to enhance existing elements by detecting bright areas above a threshold and applying an intensity-based glow. The effect works by identifying pixels that exceed the glow threshold, then amplifying them with a configurable intensity and strength. Connect Color Map (or Mix/Blend) output to in, then connect this node’s output to Final Output or to Edge Detection/Color Grading for a chain. This creates a soft, atmospheric glow around bright elements—neon, auras, or enhanced highlights. The glow radius parameter is reserved for future multi-pass implementations that would provide more accurate blur-based bloom.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "Input color to glow. Connect Color Map, Mix, or Blend output here.",
          "suggestedSources": [
            "node:color-map",
            "node:oklch-color-map-bezier",
            "node:mix",
            "node:blend-mode"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The color with glow and bloom effects applied",
          "suggestedTargets": [
            "node:final-output",
            "node:edge-detection",
            "node:color-grading",
            "node:chromatic-aberration"
          ]
        }
      ],
      "relatedItems": [
        "type:vec4",
        "node:blur",
        "node:edge-detection",
        "node:color-grading"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "noise" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "glow-bloom" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      },
      "examples": [
        "Chain: UV → Noise → Color Map → Glow → Output for a glowing grayscale pattern.",
        "Add glow after Mix or Blend to make bright blended areas bloom.",
        "Feed Glow output into Edge Detection or Color Grading for stylized looks."
      ],
      "advanced": "Glow detects pixels above the threshold and adds a halo; intensity and strength control how much. For multi-pass blur-based bloom, the radius parameter is reserved for future use."
    },
    "node:blur": {
      "title": "Blur",
      "titleType": "node",
      "tagline": "Ideal for creating depth of field, motion blur, and softening effects",
      "description": "Applies blur effects to soften and smooth the input image. The node supports multiple blur types: Gaussian (uniform blur in all directions), directional (blur along a specific angle), and radial (blur radiating from a center point). The current implementation uses a simplified softening approximation since full blur requires texture sampling of neighboring pixels. The blur amount controls the intensity of the softening effect, while the radius parameter is reserved for future multi-pass implementations that would provide true blur with proper sampling.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "The input color to blur",
          "suggestedSources": [
            "node:glow-bloom",
            "node:color-map",
            "node:mix",
            "node:edge-detection"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The blurred color output",
          "suggestedTargets": [
            "node:final-output",
            "node:glow-bloom",
            "node:edge-detection"
          ]
        }
      ],
      "relatedItems": [
        "type:vec4",
        "node:glow-bloom",
        "node:edge-detection"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "noise" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "blur" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      }
    },
    "node:edge-detection": {
      "title": "Edge Detection",
      "titleType": "node",
      "tagline": "Use this to detect edges and create outline effects for structural definition and stylized rendering",
      "description": "Detects edges in the input image and creates outline effects by identifying areas where the value crosses a threshold. The effect uses a threshold-based approach with smoothstep interpolation to create soft edge transitions. Edge width controls how gradual the edge detection is, while intensity and strength control the visual impact of the detected edges. This is useful for creating stylized outlines, enhancing structural definition, or creating cartoon-like rendering effects.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "The input color to detect edges in",
          "suggestedSources": [
            "node:glow-bloom",
            "node:color-map",
            "node:blur",
            "node:mix"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The color with edge detection effects applied",
          "suggestedTargets": [
            "node:final-output",
            "node:block-edge-brightness",
            "node:mix",
            "node:color-grading"
          ]
        }
      ],
      "relatedItems": [
        "type:vec4",
        "node:glow-bloom",
        "node:blur",
        "node:block-edge-brightness"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "noise" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "edge-detection" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      }
    },
    "node:chromatic-aberration": {
      "title": "Chromatic Aberration",
      "titleType": "node",
      "tagline": "Perfect for creating stylized color fringing effects and lens distortion artifacts",
      "description": "Separates RGB channels to create stylized color fringing effects that simulate chromatic aberration found in camera lenses. The effect shifts red and blue channels relative to the green channel based on distance from a center point and direction. This creates colorful fringes around edges, particularly useful for creating retro or glitch aesthetics. The strength controls the amount of separation, while the falloff parameter controls how the effect diminishes with distance from the center. The current implementation uses an approximation since full chromatic aberration requires texture sampling of RGB channels separately.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "The input color to apply chromatic aberration to",
          "suggestedSources": [
            "node:glow-bloom",
            "node:color-map",
            "node:blur",
            "node:mix",
            "node:edge-detection"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The color with RGB channel separation applied",
          "suggestedTargets": [
            "node:final-output",
            "node:rgb-separation",
            "node:scanlines",
            "node:block-color-glitch"
          ]
        }
      ],
      "relatedItems": [
        "type:vec4",
        "node:rgb-separation",
        "node:block-color-glitch"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "noise" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "chromatic-aberration" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      }
    },
    "node:color-grading": {
      "title": "Color Grading",
      "titleType": "node",
      "tagline": "Ideal for fine control over color curves and levels for professional color adjustment",
      "description": "Provides comprehensive color grading controls for final color adjustment, including separate adjustments for shadows, midtones, and highlights. The node applies color curve adjustments to different luminance ranges, allowing you to warm up shadows, adjust midtone saturation, or cool down highlights independently. Additionally, it includes a levels adjustment system with input/output black/white points and gamma correction for precise contrast and brightness control. This is essential for achieving professional color grading and matching specific color aesthetics.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "The input color to apply color grading to",
          "suggestedSources": [
            "node:glow-bloom",
            "node:color-map",
            "node:tone-mapping",
            "node:mix",
            "node:blend-mode"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The color-graded output with adjusted curves and levels",
          "suggestedTargets": [
            "node:final-output",
            "node:tone-mapping",
            "node:chromatic-aberration"
          ]
        }
      ],
      "relatedItems": [
        "type:vec4",
        "node:tone-mapping",
        "node:oklch-color-map-bezier",
        "node:oklch-color-map-threshold"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "noise" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "color-grading" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      },
      "examples": [
        "Chain Color Map or Glow → Color Grading → Tone Mapping → Output for full control over shadows, midtones, and highlights.",
        "Use after post-process (Blur, Edge Detection) to warm or cool the final image or adjust contrast curves.",
        "Combine with OKLCH Color Map nodes: grade the result for film-like or stylized color before Output."
      ]
    },
    "node:rgb-separation": {
      "title": "RGB Separation",
      "titleType": "node",
      "tagline": "Use this for advanced RGB channel separation with independent X/Y offsets per channel for glitch effects",
      "description": "Provides advanced RGB channel separation with independent X and Y offsets for each color channel (red, green, blue). This creates sophisticated glitch effects by shifting each channel in different directions, resulting in colorful separation artifacts. Unlike simple chromatic aberration, this node allows precise control over each channel's offset independently, enabling complex glitch patterns. The strength parameter controls the overall intensity of the separation effect. This is particularly effective for creating digital glitch aesthetics, VHS-style artifacts, or experimental visual effects.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "The input color to separate RGB channels from",
          "suggestedSources": [
            "node:color-map",
            "node:glow-bloom",
            "node:blur",
            "node:mix"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The color with RGB channel separation applied",
          "suggestedTargets": [
            "node:final-output",
            "node:chromatic-aberration",
            "node:block-color-glitch"
          ]
        }
      ],
      "relatedItems": [
        "type:vec4",
        "node:chromatic-aberration",
        "node:block-color-glitch",
        "node:scanlines"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "noise" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "rgb-separation" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect Color Map or Glow → RGB Separation → Output for per-channel offset glitch or VHS-style artifacts.",
        "Set different X/Y offsets per channel for complex separation; chain before or after Chromatic Aberration for layered color effects.",
        "Use strength to control intensity; combine with Scanlines for full retro display look."
      ]
    },
    "node:scanlines": {
      "title": "Scanlines",
      "titleType": "node",
      "tagline": "Perfect for simulating CRT monitor artifacts and retro digital display effects",
      "description": "Adds horizontal scanline overlay effects that simulate CRT monitor displays or digital display artifacts. The effect creates repeating horizontal lines across the image with configurable frequency (line spacing), thickness, and opacity. The scanlines can be static or animated with time-based scrolling for authentic retro aesthetics. This is ideal for creating nostalgic video game aesthetics, retro computing visuals, or adding vintage character to modern graphics. The time speed and offset parameters allow for animated scanline scrolling effects.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "The input color to apply scanlines to",
          "suggestedSources": [
            "node:color-map",
            "node:glow-bloom",
            "node:chromatic-aberration",
            "node:mix"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The color with scanline overlay applied",
          "suggestedTargets": [
            "node:final-output",
            "node:rgb-separation",
            "node:block-color-glitch"
          ]
        }
      ],
      "relatedItems": [
        "type:vec4",
        "node:rgb-separation",
        "node:block-color-glitch",
        "node:time"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "noise" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "scanlines" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect Color Map or Chromatic Aberration → Scanlines → Output for CRT or retro display style.",
        "Drive time into the node (or use time speed parameter) to animate scrolling scanlines.",
        "Chain with RGB Separation or Glow for layered vintage or glitch aesthetics."
      ]
    },
    "node:block-edge-brightness": {
      "title": "Edge Brightness",
      "titleType": "node",
      "tagline": "Ideal for adding brightness variation at block edges, typically used with block-displacement for glitch effects",
      "description": "Adds brightness variation at block edges, creating visual emphasis on block boundaries. This effect is designed to work in conjunction with block-displacement nodes, matching their block structure parameters (count, direction, spacing chaos) to create cohesive glitch effects. The node detects block boundaries and applies configurable brightness adjustments at the edges, with smooth transitions controlled by the edge width parameter. This creates a distinctive glitch aesthetic where block boundaries are highlighted, enhancing the visual impact of block-based distortions. The effect supports both horizontal and vertical block orientations.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "The input color to apply block edge brightness to",
          "suggestedSources": [
            "node:edge-detection",
            "node:color-map",
            "node:block-color-glitch",
            "node:mix"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The color with brightness variation at block edges",
          "suggestedTargets": [
            "node:block-color-glitch",
            "node:final-output",
            "node:mix",
            "node:chromatic-aberration"
          ]
        }
      ],
      "relatedItems": [
        "type:vec4",
        "node:block-color-glitch",
        "node:edge-detection"
      ]
    },
    "node:block-color-glitch": {
      "title": "Block Color Glitch",
      "titleType": "node",
      "tagline": "Perfect for applying color-based visual glitches using block structure for digital artifact effects",
      "description": "Applies color-based visual glitches using a block structure system. The node can operate in two modes: pre-color-mapping (modifies the result value before color mapping) or post-color-mapping (modifies RGB colors after color mapping). It offers multiple glitch effects including invert, brightness shift, threshold offset, RGB separation, hue rotation, saturation shift, color tint, and noise injection. The block parameters are automatically synced from block-displacement nodes when present. You can select which blocks are affected (all, small only, or large only) and control the intensity and amount of each effect. This creates sophisticated digital glitch aesthetics with precise control over the visual artifacts.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "The input color to apply block glitch effects to",
          "suggestedSources": [
            "node:color-map",
            "node:edge-detection",
            "node:block-edge-brightness",
            "node:mix"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The color with block-based glitch effects applied",
          "suggestedTargets": [
            "node:final-output",
            "node:chromatic-aberration",
            "node:rgb-separation",
            "node:scanlines"
          ]
        }
      ],
      "relatedItems": [
        "type:vec4",
        "node:block-edge-brightness",
        "node:rgb-separation",
        "node:chromatic-aberration"
      ]
    },
    "node:normal-mapping": {
      "title": "Normal Mapping",
      "titleType": "node",
      "tagline": "Use this to simulate surface detail using normal mapping for added depth and texture",
      "description": "Simulates surface detail and texture using normal mapping techniques. The node calculates surface normals from the input pattern and applies directional lighting to create the illusion of depth and three-dimensional surface detail. It uses a simplified gradient-based approximation to calculate normals, then applies lighting based on a configurable light direction. The normal scale controls the frequency of the surface detail, while strength controls how much the lighting effect influences the final output. This is useful for adding texture and depth to flat patterns, creating the appearance of embossed or engraved surfaces.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "The input color to apply normal mapping to",
          "suggestedSources": [
            "node:noise",
            "node:color-map",
            "node:hexagonal-grid"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The color with normal mapping and lighting applied",
          "suggestedTargets": [
            "node:lighting-shading",
            "node:final-output",
            "node:dot-product"
          ]
        }
      ],
      "relatedItems": [
        "type:vec4",
        "node:lighting-shading",
        "node:dot-product"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "noise" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "normal-mapping" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      }
    },
    "node:lighting-shading": {
      "title": "Lighting",
      "titleType": "node",
      "tagline": "Ideal for adding directional or point lighting to create depth and dimension",
      "description": "Adds directional or point lighting to create depth and dimension in the scene. The node supports two light types: directional (parallel light rays from a specific direction, like sunlight) and point (radial light emanating from a specific position with distance-based falloff). It calculates surface normals from the input pattern and applies lighting calculations based on the light direction or position. Ambient lighting provides a base illumination level, while intensity controls the strength of the directional or point light. The light color can be customized to create warm or cool lighting effects. This is essential for creating three-dimensional appearance and depth in flat patterns.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "The input color to apply lighting to",
          "suggestedSources": [
            "node:normal-mapping",
            "node:noise",
            "node:color-map",
            "node:hexagonal-grid"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The color with lighting and shading applied",
          "suggestedTargets": [
            "node:final-output",
            "node:mix",
            "node:normal-mapping"
          ]
        }
      ],
      "relatedItems": [
        "type:vec4",
        "node:normal-mapping",
        "node:dot-product",
        "node:normalize"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "noise" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "lighting-shading" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect Color Map or Normal Mapping → Lighting → Output to add directional or point light and depth.",
        "Chain: pattern → Color Map → Lighting; set light type (directional or point) and direction/position for 3D feel.",
        "Use with Normal Mapping: feed lit result back into Normal Mapping or Mix for layered shading."
      ]
    },
    "node:translate": {
      "title": "Translate",
      "titleType": "node",
      "tagline": "Shifts 2D coordinates (e.g. UV) by an X and Y offset. Use it to pan or slide a pattern across the screen.",
      "description": "Translate takes a vec2 (e.g. from UV Coords) and adds an offset so the pattern that uses those coordinates appears moved. Positive Offset X moves the pattern right, positive Offset Y moves it up. Connect UV Coords → Translate → Noise to slide the noise; adjust the parameters to see the pattern move.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "2D coordinates to shift. Usually connect UV Coords, or the output of Scale/Rotate.",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:scale",
            "node:rotate",
            "node:polar-coordinates"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "Coordinates after adding the offset. Connect to Noise, Scale, or other nodes that take vec2.",
          "suggestedTargets": [
            "node:scale",
            "node:rotate",
            "node:noise",
            "node:hexagonal-grid",
            "node:distance"
          ]
        }
      ],
      "parameters": [
        {
          "name": "Offset X",
          "description": "How much to move the coordinates horizontally. Positive values shift the pattern right on screen; negative shifts left."
        },
        {
          "name": "Offset Y",
          "description": "How much to move the coordinates vertically. Positive values shift the pattern up on screen; negative shifts down."
        }
      ],
      "relatedItems": [
        "node:rotate",
        "node:scale",
        "type:vec2",
        "node:uv-coordinates"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "translate" },
          { "id": "c", "type": "noise" },
          { "id": "d", "type": "color-map" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV → Translate → Noise → Color Map to slide the noise; drive Offset X/Y with Time for panning.",
        "Use with Scale and Rotate to position a pattern before feeding into Rings or Hexagonal Grid.",
        "Animate offset with Sine(Time) for smooth looping motion."
      ],
      "advanced": "Translate adds to coordinates; use before pattern nodes. For tiling, combine with Domain Repetition or Scale so the pattern repeats."
    },
    "node:rotate": {
      "title": "Rotate",
      "titleType": "node",
      "tagline": "Ideal for rotating coordinates around a center point by a specified angle",
      "description": "Rotates 2D coordinates around a specified center point by a given angle in radians. Uses standard rotation matrix calculations to transform the input coordinates. The rotation is counter-clockwise for positive angles. You can control both the rotation angle and the pivot point (center) of rotation.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input 2D coordinates to rotate",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale",
            "node:polar-coordinates"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "The rotated coordinates around the specified center point",
          "suggestedTargets": [
            "node:translate",
            "node:scale",
            "node:noise",
            "node:kaleidoscope",
            "node:hexagonal-grid"
          ]
        }
      ],
      "relatedItems": [
        "node:translate",
        "node:scale",
        "type:vec2",
        "node:sine",
        "node:cosine"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "rotate" },
          { "id": "c", "type": "noise" },
          { "id": "d", "type": "color-map" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      },
      "examples": [
        "Feed UV into Rotate then Noise and Color Map for a rotated pattern; drive angle with Time for spinning.",
        "Use with Polar Coords and Kaleidoscope for radial symmetry, or with Translate to place the center.",
        "Connect Sine(Time) to a center or angle for animated rotation."
      ],
      "advanced": "Angle is in radians; use Sine/Cosine of Time for smooth rotation. Rotate before pattern nodes so the whole pattern turns around the center."
    },
    "node:scale": {
      "title": "Scale",
      "titleType": "node",
      "tagline": "Makes a pattern bigger or smaller by scaling the coordinates. Scale X and Scale Y control size; Center X/Y set the point everything scales around.",
      "description": "Scale takes a vec2 (e.g. from UV Coords) and multiplies the distance from a center point. Scale X and Scale Y above 1 make the pattern repeat more (smaller tiles); below 1 make it stretch (fewer, bigger repeats). Center X and Center Y set the point around which scaling happens (0.5, 0.5 is the middle of the screen).",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "2D coordinates to scale. Usually UV Coords or Translate/Rotate output.",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:rotate",
            "node:polar-coordinates"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "Scaled coordinates. Connect to Noise, Translate, or other vec2 inputs.",
          "suggestedTargets": [
            "node:translate",
            "node:rotate",
            "node:noise",
            "node:hexagonal-grid",
            "node:wave-patterns"
          ]
        }
      ],
      "parameters": [
        {
          "name": "Scale X",
          "description": "How much to stretch coordinates horizontally. Higher = smaller repeating pattern (more tiles); lower = stretched, fewer repeats."
        },
        {
          "name": "Scale Y",
          "description": "How much to stretch coordinates vertically. Higher = more vertical repeats; lower = stretched vertically."
        },
        {
          "name": "Center X",
          "description": "Horizontal position of the center point that scaling is relative to. 0.5 = middle of screen; change to zoom from a different point."
        },
        {
          "name": "Center Y",
          "description": "Vertical position of the center point that scaling is relative to. 0.5 = middle of screen; change to zoom from a different point."
        }
      ],
      "relatedItems": [
        "node:translate",
        "node:rotate",
        "type:vec2",
        "node:multiply"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "scale" },
          { "id": "c", "type": "noise" },
          { "id": "d", "type": "color-map" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      }
    },
    "node:domain-repetition": {
      "title": "Domain Repetition",
      "titleType": "node",
      "tagline": "Tile UVs so any upstream pattern repeats; output is in 0–1 per tile plus optional offset",
      "description": "Transforms 2D coordinates so that downstream patterns tile seamlessly. Uses fract(uv * scale) plus an optional offset, so the output stays in 0–1 per cell. Connect UV (or other vec2) into Domain Repetition, then feed its output into any pattern node (e.g. fBm Noise, Rings) to get a repeating tiled result. Scale X/Y control how many tiles; offset shifts the tile phase.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Input coordinates (e.g. UV) to tile",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale",
            "node:rotate"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "Tiled coordinates in 0–1 per cell plus offset",
          "suggestedTargets": [
            "node:noise",
            "node:rings",
            "node:wave-patterns",
            "node:hexagonal-grid",
            "node:flow-field-pattern"
          ]
        }
      ],
      "relatedItems": [
        "node:translate",
        "node:scale",
        "node:fract"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "domain-repetition" },
          { "id": "c", "type": "noise" },
          { "id": "d", "type": "color-map" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      }
    },
    "node:polar-coordinates": {
      "title": "Polar Coords",
      "titleType": "node",
      "tagline": "Perfect for converting Cartesian coordinates to polar coordinates, enabling radial and rotational effects",
      "description": "Converts 2D Cartesian coordinates to polar coordinates (angle and radius), applies scaling and rotation transformations, then converts back to Cartesian. This enables radial effects, circular patterns, and rotational distortions. You can control the center point, angular scale, radial scale, and rotation. The conversion allows for effects that are naturally expressed in polar space, such as radial gradients, circular patterns, and rotational symmetries.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input 2D Cartesian coordinates to convert",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale",
            "node:rotate"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "The transformed coordinates after polar conversion, scaling, and rotation",
          "suggestedTargets": [
            "node:rings",
            "node:kaleidoscope",
            "node:twist-distortion",
            "node:arc-tangent-2",
            "node:length"
          ]
        }
      ],
      "relatedItems": [
        "node:rotate",
        "node:scale",
        "type:vec2",
        "node:arc-tangent-2",
        "node:length"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "polar-coordinates" },
          { "id": "c", "type": "length" },
          { "id": "d", "type": "color-map" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV → Polar Coords → Rings (or Length → Color Map) for radial patterns and circular gradients.",
        "Use before Kaleidoscope or Twist for rotational symmetry; adjust center and scales to match your layout.",
        "Feed into Arc Tangent 2 and Length for angle/radius; combine with Noise for polar-distorted noise."
      ],
      "advanced": "Converts (x,y) to angle and radius, scales and rotates, then back to Cartesian. Use for any effect that is easier in polar space (rings, spirals, radial blur)."
    },
    "node:kaleidoscope": {
      "title": "Kaleidoscope",
      "titleType": "node",
      "tagline": "Ideal for creating symmetric patterns by mirroring and reflecting sections of the image",
      "description": "Creates kaleidoscope effects by dividing the coordinate space into segments and mirroring each segment to create symmetric patterns. The node calculates the angle and radius from the center point, determines which segment the coordinate falls into, and mirrors coordinates in the second half of each segment to the first half. This creates beautiful radial symmetry patterns. You can control the number of segments (2-32), the center point, and rotation offset.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input 2D coordinates to apply kaleidoscope transformation to",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:polar-coordinates",
            "node:rotate",
            "node:translate"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "The mirrored coordinates creating symmetric kaleidoscope patterns",
          "suggestedTargets": [
            "node:noise",
            "node:hexagonal-grid",
            "node:color-map"
          ]
        }
      ],
      "relatedItems": [
        "node:polar-coordinates",
        "node:rotate",
        "type:vec2",
        "node:arc-tangent-2"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "kaleidoscope" },
          { "id": "c", "type": "length" },
          { "id": "d", "type": "color-map" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      },
      "examples": [
        "Feed UV or Polar Coords into Kaleidoscope, then Noise or Length → Color Map for symmetric patterns.",
        "Increase segments for more mirrors (e.g. 6 for hex symmetry); rotate for animated kaleidoscope.",
        "Combine with Rings or Radial Rays for mandala-style effects."
      ],
      "advanced": "Segments divide the circle; each segment is mirrored. Use with Polar Coords for clean radial symmetry; odd segment counts can produce different symmetry than even."
    },
    "node:twist-distortion": {
      "title": "Twist",
      "titleType": "node",
      "tagline": "Use this to apply rotational distortion around a center point, creating spiral and twist effects",
      "description": "Applies rotational distortion (twist) around a specified center point, creating spiral and vortex effects. The twist amount varies based on distance from the center, with stronger effects near the center that fall off with distance. The node calculates the angle of each point relative to the center, adds a twist amount based on distance and strength parameters, then reconstructs the position. You can control the center point, twist strength, radius of effect, falloff rate, and optional time-based animation.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input 2D coordinates to apply twist distortion to",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:polar-coordinates",
            "node:rotate",
            "node:translate"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "The twisted coordinates with rotational distortion applied",
          "suggestedTargets": [
            "node:noise",
            "node:wave-patterns",
            "node:color-map"
          ]
        }
      ],
      "relatedItems": [
        "node:rotate",
        "node:polar-coordinates",
        "type:vec2",
        "node:smoothstep",
        "node:arc-tangent-2"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "twist-distortion" },
          { "id": "c", "type": "length" },
          { "id": "d", "type": "color-map" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV or Polar Coords → Twist → Noise (or Length) → Color Map for spiral and vortex effects.",
        "Drive strength or center with Time for animated twist; use falloff to limit effect to a region.",
        "Chain after Ripple or Vector Field for combined warping."
      ],
      "advanced": "Twist adds angle proportional to distance from center. Use Radius and Falloff to confine the effect; combine with Vortex for stronger spiral pull."
    },
    "node:turbulence": {
      "title": "Turbulence",
      "titleType": "node",
      "tagline": "Perfect for applying multi-stage coordinate warping to create complex, organic distortions",
      "description": "Applies multi-stage domain warping using iterative noise-based distortions. The node performs multiple iterations of noise sampling at different scales, accumulating distortions to create complex, organic-looking warping effects. Each iteration uses a different scale (powers of 2), creating fractal-like distortion patterns. The effect can be animated over time and controlled through scale, strength, number of iterations, and time-based parameters. This creates fluid, turbulent distortions similar to water, smoke, or heat haze effects.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input 2D coordinates to apply turbulence distortion to",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:noise",
            "node:vector-field"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "The warped coordinates after multi-stage turbulence distortion",
          "suggestedTargets": [
            "node:noise",
            "node:color-map",
            "node:translate"
          ]
        }
      ],
      "relatedItems": [
        "node:vector-field",
        "type:vec2",
        "node:multiply",
        "node:time"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "turbulence" },
          { "id": "c", "type": "length" },
          { "id": "d", "type": "color-map" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV → Turbulence → Noise or Length → Color Map for organic, fluid-like distortion.",
        "Drive time speed with Time for animated turbulence; increase iterations for more complexity.",
        "Feed Turbulence output into Displace or another pattern for layered warping."
      ],
      "advanced": "Multi-octave domain warping; each iteration samples noise at different scales. More iterations add detail but cost; use for heat haze, water, or abstract flow."
    },
    "node:vector-field": {
      "title": "Vector Field",
      "titleType": "node",
      "tagline": "Ideal for creating warping effects using a vector field that distorts UV coordinates",
      "description": "Applies vector field-based distortion to coordinates, creating complex warping effects. The node generates a vector field using trigonometric functions with configurable frequencies, then uses this field to offset coordinates. The vector field includes harmonic layers for complexity, radial strength for distance-based effects, and can be animated over time. The distortion is calculated using dot products and cross products (2D equivalent) to create directional warping. This creates flowing, dynamic distortions that can simulate fluid motion, magnetic fields, or abstract warping effects.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input 2D coordinates to apply vector field distortion to",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:turbulence",
            "node:normalize"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "The distorted coordinates after vector field transformation",
          "suggestedTargets": [
            "node:turbulence",
            "node:noise",
            "node:translate",
            "node:color-map"
          ]
        }
      ],
      "relatedItems": [
        "node:turbulence",
        "node:translate",
        "type:vec2",
        "node:dot-product",
        "node:cosine",
        "node:sine"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "vector-field" },
          { "id": "c", "type": "length" },
          { "id": "d", "type": "color-map" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV → Vector Field → Noise or Length → Color Map for flowing, directional warping.",
        "Animate with Time for moving flow; tune frequency and strength for subtle or strong distortion.",
        "Chain with Turbulence for complex organic motion."
      ],
      "advanced": "Vector field offsets coordinates using trig-based directions. Use Radial Strength for distance-based effect; combine with Turbulence for layered distortion."
    },
    "node:bulge-pinch": {
      "title": "Bulge / Pinch",
      "titleType": "node",
      "tagline": "Radial displacement from a center; positive strength bulges, negative pinches",
      "description": "Applies radial displacement from a center point. Positive strength bulges coordinates outward (lens/magnify effect); negative strength pinches them inward. Radius and falloff control the extent and smoothness of the effect.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Input coordinates",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "Distorted coordinates",
          "suggestedTargets": [
            "node:noise",
            "node:color-map",
            "node:scale"
          ]
        }
      ],
      "relatedItems": [
        "node:twist-distortion",
        "node:fisheye",
        "node:polar-coordinates"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "bulge-pinch" },
          { "id": "c", "type": "length" },
          { "id": "d", "type": "color-map" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      }
    },
    "node:ripple": {
      "title": "Ripple",
      "titleType": "node",
      "tagline": "Sine-wave displacement; concentric or directional for water/glass effects",
      "description": "Displaces coordinates with sine waves. Concentric mode creates circular ripples from a center; Directional mode creates a grid of waves. Frequency, amplitude, phase and optional time speed control the effect.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Input coordinates",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:polar-coordinates"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "Rippled coordinates",
          "suggestedTargets": [
            "node:noise",
            "node:color-map",
            "node:twist-distortion"
          ]
        }
      ],
      "relatedItems": [
        "node:wave-patterns",
        "node:twist-distortion",
        "node:vector-field"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "ripple" },
          { "id": "c", "type": "length" },
          { "id": "d", "type": "color-map" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      }
    },
    "node:fisheye": {
      "title": "Fisheye",
      "titleType": "node",
      "tagline": "Lens-style radial distortion; barrel or pincushion",
      "description": "Applies lens-style radial distortion. Negative strength gives barrel (fisheye) distortion; positive gives pincushion. Center and aspect ratio are configurable.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Input coordinates",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "Distorted coordinates",
          "suggestedTargets": [
            "node:chromatic-aberration",
            "node:color-map",
            "node:blur"
          ]
        }
      ],
      "relatedItems": [
        "node:bulge-pinch",
        "node:polar-coordinates"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "fisheye" },
          { "id": "c", "type": "length" },
          { "id": "d", "type": "color-map" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      }
    },
    "node:mirror-flip": {
      "title": "Mirror / Flip",
      "titleType": "node",
      "tagline": "Flip coordinates horizontally and/or vertically",
      "description": "Flips input coordinates around an optional center. Enable Flip X and/or Flip Y for mirroring. Useful for symmetry and avoiding duplicate artwork.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Input coordinates",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:scale"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "Flipped coordinates",
          "suggestedTargets": [
            "node:kaleidoscope",
            "node:noise",
            "node:color-map"
          ]
        }
      ],
      "relatedItems": [
        "node:kaleidoscope",
        "node:scale"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "mirror-flip" },
          { "id": "c", "type": "length" },
          { "id": "d", "type": "color-map" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      },
      "examples": [
        "Flip X and/or Y for mirror symmetry; connect UV → Mirror/Flip → pattern for reflected layout.",
        "Use with Kaleidoscope or tiling patterns to avoid drawing both sides of a symmetric design.",
        "Set center for flip-around-point instead of screen edges."
      ],
      "advanced": "Flips coordinates; no scaling. Use before pattern nodes so the pattern itself is mirrored. Combine with Scale for flip then zoom."
    },
    "node:displace": {
      "title": "Displace",
      "titleType": "node",
      "tagline": "Offset coordinates by a vector from noise or gradient",
      "description": "Adds an offset vector to the input coordinates. Connect a vec2 from noise, gradient, or flow to drive the distortion. Scale multiplies the offset.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Input coordinates",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates"
          ]
        },
        {
          "name": "offset",
          "type": "vec2",
          "description": "Displacement vector",
          "suggestedSources": [
            "node:noise",
            "node:cubic-curl-noise",
            "node:combine-vector"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "Displaced coordinates",
          "suggestedTargets": [
            "node:noise",
            "node:color-map"
          ]
        }
      ],
      "relatedItems": [
        "node:vector-field",
        "node:turbulence",
        "node:combine-vector"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "displace" },
          { "id": "c", "type": "length" },
          { "id": "d", "type": "color-map" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "offset" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV to in, and a vec2 (Noise via Combine Vector, or Cubic Curl Noise) to offset for displacement.",
        "Scale the offset to control strength; feed displaced coords into another Noise or pattern.",
        "Use with Vector Field or Warp Terrain for directional or organic displacement."
      ],
      "advanced": "Adds offset vector to coordinates. Use Cubic Curl Noise or Combine Vector for vec2; single-channel noise won't work. Scale multiplies the offset strength."
    },
    "node:vortex": {
      "title": "Vortex",
      "titleType": "node",
      "tagline": "Spiral pull toward center for drain/portal effects",
      "description": "Pulls and rotates coordinates toward a center point, creating a spiral vortex. Strength, radius and falloff control the effect; optional time speed animates the spin.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Input coordinates",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:polar-coordinates"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "Vortex-distorted coordinates",
          "suggestedTargets": [
            "node:noise",
            "node:color-map",
            "node:twist-distortion"
          ]
        }
      ],
      "relatedItems": [
        "node:twist-distortion",
        "node:polar-coordinates"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "vortex" },
          { "id": "c", "type": "length" },
          { "id": "d", "type": "color-map" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV or Polar Coords → Vortex → Noise or Length → Color Map for drain or portal spin.",
        "Animate time speed for rotating vortex; tune radius and falloff to limit the spiral region.",
        "Combine with Twist for stronger spiral, or with Ripple for spinning ripples."
      ],
      "advanced": "Pulls coordinates toward center with rotation; strength and radius set the effect. Use for drain holes, portals, or spiral focus effects."
    },
    "node:spherize": {
      "title": "Spherize",
      "titleType": "node",
      "tagline": "Map rectangle to hemisphere for 3D ball/planet effect",
      "description": "Maps 2D coordinates onto a hemisphere so patterns wrap like a sphere. Center, radius and strength control the spherize amount.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Input coordinates",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "Spherized coordinates",
          "suggestedTargets": [
            "node:sphere-raymarch",
            "node:color-map",
            "node:lighting-shading"
          ]
        }
      ],
      "relatedItems": [
        "node:sphere-raymarch",
        "node:polar-coordinates"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "spherize" },
          { "id": "c", "type": "length" },
          { "id": "d", "type": "color-map" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV → Spherize → Length or pattern → Color Map for ball or planet-like wrapping.",
        "Set center and radius to frame the hemisphere; strength controls how much the map bends.",
        "Feed into Sphere Raymarch or Lighting/Shading for 3D-style presentation."
      ],
      "advanced": "Maps 2D to hemisphere; use for fake 3D spheres or globes. Center and radius define the circular region; strength controls curvature."
    },
    "node:quad-warp": {
      "title": "Quad Warp",
      "titleType": "node",
      "tagline": "Map unit square to a quadrilateral for perspective/screen effects",
      "description": "Maps input (u,v) from the unit square to a quadrilateral defined by four corners (BL, BR, TL, TR). Use for perspective distortion, screens, and poster effects.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Input coordinates (e.g. 0–1)",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "Warped coordinates",
          "suggestedTargets": [
            "node:noise",
            "node:color-map"
          ]
        }
      ],
      "relatedItems": [
        "node:scale",
        "node:rotate"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "quad-warp" },
          { "id": "c", "type": "length" },
          { "id": "d", "type": "color-map" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV → Quad Warp → Noise or Length → Color Map for perspective or screen distortion.",
        "Set the four corners (BL, BR, TL, TR) to shape the quad; use for fake 3D planes or posters.",
        "Animate corners with Time or Sine for warping screens or flags."
      ],
      "advanced": "Bilinear map from unit square to quadrilateral. Use for perspective correction, TV screens, or any four-corner warp."
    },
    "node:directional-displace": {
      "title": "Directional Displace",
      "titleType": "node",
      "tagline": "Displace along a fixed direction by a scalar amount",
      "description": "Offsets coordinates along a single direction (angle). Connect a float for the amount (e.g. from noise or gradient) and set the angle. Scale multiplies the displacement.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Input coordinates",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates"
          ]
        },
        {
          "name": "amount",
          "type": "float",
          "description": "Displacement amount",
          "suggestedSources": [
            "node:noise",
            "node:time"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "Displaced coordinates",
          "suggestedTargets": [
            "node:displace",
            "node:color-map"
          ]
        }
      ],
      "relatedItems": [
        "node:displace",
        "node:vector-field"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "directional-displace" },
          { "id": "c", "type": "length" },
          { "id": "d", "type": "color-map" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV to in and a float (Noise, Time) to amount; set angle for displacement direction.",
        "Use for directional smear or stretch; scale the amount to control strength.",
        "Chain with Displace for combined vector + directional offset."
      ],
      "advanced": "Displaces along one angle only; use when you need directional smear. For 2D offset use Displace with a vec2."
    },
    "node:brick-tiling": {
      "title": "Brick Tiling",
      "titleType": "node",
      "tagline": "Tiled coords with row offset for brick and staggered patterns",
      "description": "Tiles coordinates with an optional horizontal offset on alternating rows (brick/staggered layout). Scale X/Y and row offset X control the tiling.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Input coordinates",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:domain-repetition"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "Brick-tiled coordinates",
          "suggestedTargets": [
            "node:noise",
            "node:dots",
            "node:color-map"
          ]
        }
      ],
      "relatedItems": [
        "node:domain-repetition",
        "node:hexagonal-grid"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "brick-tiling" },
          { "id": "c", "type": "length" },
          { "id": "d", "type": "color-map" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      }
    },
    "node:infinite-zoom": {
      "title": "Infinite Zoom",
      "titleType": "node",
      "tagline": "Scale and wrap for recursive zoom/tunnel effect",
      "description": "Scales coordinates by a time-dependent factor and wraps them to create a repeating zoom/tunnel effect. Center, scale and time speed are configurable.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Input coordinates",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "Zoomed/wrapped coordinates",
          "suggestedTargets": [
            "node:noise",
            "node:voronoi-noise",
            "node:color-map"
          ]
        }
      ],
      "relatedItems": [
        "node:domain-repetition",
        "node:scale"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "infinite-zoom" },
          { "id": "c", "type": "length" },
          { "id": "d", "type": "color-map" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      }
    },
    "node:kaleidoscope-smooth": {
      "title": "Kaleidoscope Smooth",
      "titleType": "node",
      "tagline": "Kaleidoscope with smooth folding at segment edges",
      "description": "Like Kaleidoscope but uses smooth folding at segment boundaries for softer, more continuous symmetry. Segments, rotation and smooth edge width are configurable.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Input coordinates",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:polar-coordinates"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "Smooth kaleidoscope coordinates",
          "suggestedTargets": [
            "node:noise",
            "node:color-map",
            "node:kaleidoscope"
          ]
        }
      ],
      "relatedItems": [
        "node:kaleidoscope",
        "node:polar-coordinates"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "kaleidoscope-smooth" },
          { "id": "c", "type": "length" },
          { "id": "d", "type": "color-map" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      }
    },
    "node:noise": {
      "title": "Noise",
      "titleType": "node",
      "tagline": "Creates a random-looking pattern from coordinates. Feed it UV (or translated/scaled UV) and get a float you can turn into color or use for effects.",
      "description": "Noise takes a vec2 (usually from UV Coords) and outputs a float that looks random but is smooth and repeatable. You can choose the style (Mode), change how big or detailed the pattern is (Scale, Octaves), and animate it with Time. Connect the output to Color Map then Output to see it as grayscale, or use it to drive other effects.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Position to sample noise at. Connect UV Coords, or Translate/Scale for shifted or zoomed noise.",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale",
            "node:polar-coordinates"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "Noise value (about 0–1). Connect to Color Map to see it, or to Mix/Smoothstep for effects.",
          "suggestedTargets": [
            "node:color-map",
            "node:mix",
            "node:smoothstep",
            "node:gradient-mask",
            "node:translate"
          ]
        }
      ],
      "parameters": [
        {
          "name": "Mode",
          "description": "Noise style: Simplex 2D (smooth 2D), Simplex 3D (smoother, can animate with time), or Value fBm (more jagged, terrain-like). Simplex 2D/3D look smoother; Value fBm looks more rough and layered."
        },
        {
          "name": "Scale",
          "description": "How big the noise features are. Higher = larger blobs and smoother variation; lower = finer grain."
        },
        {
          "name": "Octaves",
          "description": "How many layers of detail are combined. More octaves = finer, more detailed pattern; fewer = simpler, softer look."
        },
        {
          "name": "Lacunarity",
          "description": "How much each octave is scaled. Affects the spacing of detail layers; higher = more contrast between fine and coarse detail."
        },
        {
          "name": "Gain",
          "description": "How much each octave contributes. Lower gain = smoother; higher = more contrast and sharp variation."
        },
        {
          "name": "Intensity",
          "description": "Overall strength of the noise (multiplier on the result). Higher = brighter/stronger effect when connected to Color Map or other nodes."
        },
        {
          "name": "Time Speed",
          "description": "Speed of time-based animation (for Simplex 3D or animated modes). Higher = faster motion or morphing of the pattern over time."
        },
        {
          "name": "Time Offset",
          "description": "Offset added to time so you can phase-shift the animation. Change to start the animation at a different point without changing speed."
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          {
            "id": "a",
            "type": "uv-coordinates"
          },
          {
            "id": "b",
            "type": "noise"
          },
          {
            "id": "c",
            "type": "color-map"
          },
          {
            "id": "d",
            "type": "final-output"
          }
        ],
        "connections": [
          {
            "from": "a",
            "fromPort": "out",
            "to": "b",
            "toPort": "in"
          },
          {
            "from": "b",
            "fromPort": "out",
            "to": "c",
            "toPort": "in"
          },
          {
            "from": "c",
            "fromPort": "out",
            "to": "d",
            "toPort": "in"
          }
        ]
      },
      "relatedItems": [
        "node:voronoi-noise",
        "type:vec2",
        "node:time"
      ],
      "examples": [
        "Connect UV to in, then output to Color Map and Output to see grayscale noise on screen.",
        "Feed Translate or Scale output into in for shifted or zoomed noise; connect Time for animation.",
        "Use noise output with Mix or Smoothstep to drive masks, or with Translate for displacement."
      ],
      "advanced": "Simplex 2D is fast and smooth for static 2D; Simplex 3D accepts a third coordinate (e.g. time) for animated noise. Value fBm (fractal Brownian motion) stacks octaves for rougher, terrain-like variation."
    },
    "node:warp-terrain": {
      "title": "Warp Terrain",
      "titleType": "node",
      "tagline": "Domain-warped terrain/cloud from 2D value noise FBM with normals and shading (IQ Warp style)",
      "description": "Produces an animated organic terrain or cloud pattern using domain-warped 2D value noise FBM with a rotation matrix, finite-difference normals, and simple shading. Based on Inigo Quilez's Warp tutorial. Parameters: Scale (terrain scale), Time Speed (animation), Vignette (edge darkening). Connect UV coordinates to the input; output is vec4 color ready for final output or further effects.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Input coordinates (e.g. UV 0–1)",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:fragment-coordinates",
            "node:translate"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "RGBA color of the warped terrain",
          "suggestedTargets": [
            "node:final-output",
            "node:mix",
            "node:blend-mode",
            "node:color-grading"
          ]
        }
      ],
      "relatedItems": [
        "node:noise",
        "node:turbulence",
        "node:flow-field-pattern",
        "type:vec2",
        "node:time"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "warp-terrain" },
          { "id": "c", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" }
        ]
      }
    },
    "node:cubic-curl-noise": {
      "title": "Curl Noise",
      "titleType": "node",
      "tagline": "Curl noise magnitude for flow-like, organic patterns",
      "description": "Outputs the magnitude of the 2D curl of a 3D potential (cubic value noise with time as z), producing flow-like, divergence-free variation. Parameters: scale, intensity, and time speed/offset. Output is a float in 0–1 range. Use with color-map or flow-field-pattern for flow effects; for general scalar noise use the Noise node instead.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Input UV coordinates to sample the noise",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale",
            "node:polar-coordinates"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "Curl magnitude 0–1",
          "suggestedTargets": [
            "node:color-map",
            "node:mix",
            "node:flow-field-pattern",
            "node:smoothstep"
          ]
        }
      ],
      "relatedItems": [
        "node:noise",
        "node:flow-field-pattern",
        "type:vec2",
        "node:time"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "cubic-curl-noise" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV → Curl Noise → Color Map (or Flow Field Pattern) for flow-like organic patterns.",
        "Drive with Time for animated flow; use with Displace offset for divergence-free displacement.",
        "Combine with Noise or Voronoi for mixed organic and cellular looks."
      ],
      "advanced": "Curl of a 3D potential gives divergence-free flow; use when you want smooth, swirling variation. For general scalar noise use the Noise node instead."
    },
    "node:rings": {
      "title": "Rings",
      "titleType": "node",
      "tagline": "Perfect for creating concentric ring patterns with customizable spacing and falloff",
      "description": "Generates concentric ring patterns radiating from a center point. The rings are created by calculating the distance from the center and applying a repeating pattern with configurable frequency and falloff. You can control the center position, ring count (frequency), ring width, and falloff curve to create various effects from sharp concentric circles to soft radial gradients. This is ideal for creating ripple effects, target patterns, or radial organizational structures.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input UV coordinates to generate rings from",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:polar-coordinates",
            "node:translate",
            "node:distance"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The ring pattern value (typically 0.0 to 1.0 range)",
          "suggestedTargets": [
            "node:color-map",
            "node:mix",
            "node:smoothstep",
            "node:gradient-mask"
          ]
        }
      ],
      "relatedItems": [
        "node:polar-coordinates",
        "node:distance",
        "type:vec2",
        "node:fract"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "rings" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV or Polar Coords → Rings → Color Map for concentric circles; tune frequency and falloff.",
        "Use with Domain Repetition for tiled rings; feed into Mix or Smoothstep for masks.",
        "Combine with Noise or Gradient for blended radial effects."
      ],
      "advanced": "Rings are based on distance from center with repeating phase. Use Polar Coords for best results; falloff softens the ring edges."
    },
    "node:triangle-grid": {
      "title": "Triangle Grid",
      "titleType": "node",
      "tagline": "Regular triangular tiling with configurable edges and optional fill",
      "description": "Creates a regular triangular grid by placing three families of lines at 0°, 60°, and 120°. You can control scale (cell size), line width, and intensity. Optionally enable fill to output alternating filled triangles instead of edges only. Ideal for geometric backgrounds, low-poly style, or tessellation effects when connected to a color map.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input UV coordinates for the grid",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The triangle grid pattern (0.0 to 1.0)",
          "suggestedTargets": [
            "node:color-map",
            "node:mix",
            "node:smoothstep"
          ]
        }
      ],
      "relatedItems": [
        "node:hexagonal-grid",
        "node:plane-grid",
        "type:vec2"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "triangle-grid" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV → Triangle Grid → Color Map for low-poly or tessellation style; enable fill for solid triangles.",
        "Use with Domain Repetition or Scale for tiled triangles; mix with Noise for organic edges.",
        "Tune scale and line width for sharp edges or soft bands."
      ],
      "advanced": "Three line families at 0°, 60°, 120°; fill alternates triangle cells. Use for geometric backgrounds or as a mask source."
    },
    "node:spiral": {
      "title": "Spiral",
      "titleType": "node",
      "tagline": "Spiral pattern with configurable density, rotation, arms, and thickness",
      "description": "Generates a spiral pattern from a center point. Uses polar coordinates: spiral phase is derived from angle plus density times radius, with optional time phase for animation. You can set the number of arms, band thickness, and intensity. Ideal for galaxies, whirlpools, or decorative spiral effects when fed into a color map or mix node.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input UV coordinates to generate the spiral from",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:polar-coordinates",
            "node:translate"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The spiral band pattern value (0.0 to 1.0 range)",
          "suggestedTargets": [
            "node:color-map",
            "node:mix",
            "node:smoothstep",
            "node:gradient-mask"
          ]
        }
      ],
      "relatedItems": [
        "node:rings",
        "node:polar-coordinates",
        "node:twist-distortion",
        "type:vec2"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "spiral" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV or Polar Coords → Spiral → Color Map for galaxy or whirlpool patterns.",
        "Set arms and density for spiral count; animate time phase for rotating spiral.",
        "Use with Mix or Gradient Mask for spiral-shaped masks or blended effects."
      ],
      "advanced": "Spiral phase is angle + density×radius; arms and thickness shape the bands. Use Polar Coords for clean radial spirals."
    },
    "node:sphere-raymarch": {
      "title": "Sphere Raymarch",
      "titleType": "node",
      "tagline": "Ideal for rendering 3D spheres using raymarching techniques for volumetric effects",
      "description": "Renders 3D spheres using raymarching, a technique that marches rays through space to find intersections with the sphere surface. This creates volumetric, three-dimensional sphere shapes that can be positioned, scaled, and rotated in 3D space. The node calculates ray-sphere intersections and applies lighting and shading to create realistic 3D appearance. You can control the sphere's position, size, and rotation, as well as lighting parameters. This is essential for creating 3D geometric shapes in a 2D shader environment.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input UV coordinates to raymarch from"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The raymarched sphere result (distance or surface value)"
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "sphere-raymarch" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:box-torus-sdf",
        "node:distance",
        "type:vec2",
        "node:normalize"
      ],
      "examples": [
        "Connect Look-at Camera or Orbit Camera ro/rd to drive the ray; feed UV to the node input, then output to Color Map or Mix for shading.",
        "Use for a single 3D sphere with volumetric feel; pair with other SDF nodes or Primitives for multi-shape scenes.",
        "Animate position or scale via parameters or connected vec3 for moving or pulsing spheres."
      ],
      "advanced": "Raymarching marches a ray step-by-step until it hits the sphere; the node uses a built-in sphere SDF. For multiple primitives (box, torus, etc.), use Primitives (box-torus-sdf) or Generic SDF Raymarcher with graph SDFs."
    },
    "node:spherical-fibonacci": {
      "title": "Spherical Fibonacci",
      "titleType": "node",
      "tagline": "Maps between sphere direction and spherical Fibonacci lattice index for even spot distribution",
      "description": "Provides bidirectional mapping between a unit sphere direction (vec3) and a spherical Fibonacci lattice index: direction to index (sf2id), index to direction (id2sf), and the nearest lattice point. Uses the golden-ratio lattice (Keinert et al.) for nearly uniform point distribution on the sphere. Lattice count (N) controls the number of points (4–4096). Connect direction to get index and nearest point; connect index to get the corresponding direction. Reusable primitive for bloom-sphere and other \"points on sphere\" effects.",
      "inputs": [
        {
          "name": "direction",
          "type": "vec3",
          "description": "Unit direction on the sphere; when unconnected, uses Direction X/Y/Z parameters",
          "suggestedSources": [
            "type:vec3",
            "node:normalize",
            "node:constant-vec3"
          ]
        },
        {
          "name": "index",
          "type": "float",
          "description": "Lattice index in [0, N-1]; when unconnected, uses Index parameter",
          "suggestedSources": [
            "type:float",
            "node:constant-float",
            "node:floor",
            "node:multiply"
          ]
        }
      ],
      "outputs": [
        {
          "name": "index",
          "type": "float",
          "description": "Nearest lattice index for the input direction (from sf2id)",
          "suggestedTargets": [
            "node:floor",
            "node:multiply",
            "node:smoothstep",
            "node:mix"
          ]
        },
        {
          "name": "direction",
          "type": "vec3",
          "description": "Sphere direction for the input index (from id2sf)",
          "suggestedTargets": [
            "node:dot-product",
            "node:mix",
            "node:normalize",
            "node:final-output"
          ]
        },
        {
          "name": "nearestPoint",
          "type": "vec3",
          "description": "Nearest lattice point on the unit sphere to the input direction",
          "suggestedTargets": [
            "node:dot-product",
            "node:distance",
            "node:mix"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "orbit-camera" },
          { "id": "c", "type": "spherical-fibonacci" },
          { "id": "d", "type": "color-map" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "rd", "to": "c", "toPort": "direction" },
          { "from": "c", "fromPort": "index", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:sphere-raymarch",
        "node:normalize",
        "type:vec3",
        "type:float"
      ]
    },
    "node:bloom-sphere": {
      "title": "Bloom Sphere",
      "titleType": "node",
      "tagline": "Sphere with evenly distributed soft spots that pulse in a wave, blue outer glow and reddish inner glow",
      "description": "Renders a sphere covered in soft spots placed on a spherical Fibonacci lattice, with a time-based wave that modulates spot size. Uses analytic ray-sphere intersection and soft projected masks. Outer glow uses the blue color; inner (facing) areas use the red color. Connect UV to in; output is vec4 for final output or blending. Spot count, wave speed, and colors are adjustable. No temporal buffer; single-pass spatial effect.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "UV coordinates (e.g. from UV Coords) to raymarch from",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "RGBA color; connect to Final Output or blend with other nodes",
          "suggestedTargets": [
            "node:final-output",
            "node:blend-mode",
            "node:mix",
            "node:glow-bloom"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "bloom-sphere" },
          { "id": "c", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:sphere-raymarch",
        "node:spherical-fibonacci",
        "node:sky-dome",
        "type:vec2",
        "type:vec4"
      ],
      "examples": [
        "Connect UV to in; output goes to Final Output or Mix with a background (e.g. Sky Dome) for a full scene.",
        "Adjust spot count and wave speed for denser or calmer pulse; use outer/inner glow colors for different moods.",
        "Layer with other vec4 nodes (e.g. Blend Mode or Mix) for composite visuals without temporal buffer."
      ],
      "advanced": "Uses the same spherical Fibonacci lattice as the Spherical Fibonacci node for spot placement; analytic ray-sphere intersection keeps it single-pass. For modular reuse of the lattice elsewhere, use Spherical Fibonacci + Bloom Sphere."
    },
    "node:bloom-sphere-effect": {
      "title": "Bloom Sphere (Effect)",
      "titleType": "node",
      "tagline": "Sphere with spherical Fibonacci spots, time wave, and blue/red glow (modular path)",
      "description": "Renders a sphere with evenly distributed soft spots using the same spherical Fibonacci lattice as the Spherical Fibonacci node (self-contained). Implements analytic ray-sphere intersection, soft spot masks, a time-based radius wave, and blue outer / reddish inner glow to replicate the Shadertoy Xljcz1 look. Connect UV (e.g. from UV Coords). Parameters: spot count (lattice size), radius, wave speed, spot sharpness, and outer/inner glow colors. Uses embedded lattice math; the Spherical Fibonacci node can be used elsewhere in the graph for other effects.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "UV coordinates (e.g. from UV Coords)",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "RGBA color; connect to Final Output or blend with other nodes",
          "suggestedTargets": [
            "node:final-output",
            "node:mix",
            "node:blend-mode"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "bloom-sphere-effect" },
          { "id": "c", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:spherical-fibonacci",
        "node:bloom-sphere",
        "node:sphere-raymarch",
        "node:uv-coordinates",
        "type:vec2",
        "type:vec4"
      ]
    },
    "node:hex-voxel": {
      "title": "Hex Voxel",
      "titleType": "node",
      "tagline": "2D view over a 3D voxel field as hex-grid slices with layered composite and optional glow",
      "description": "Renders a 3D voxel field as stacked hex-grid slices using a painter's-algorithm composite (front-to-back). Each slice is voxelized with an IQ-style hex coordinate system; a built-in 3D SDF is sampled at voxel coordinates. View orbit: Yaw (left/right) and Pitch (up/down) rotate the 3D scene so both axes are independent. Shape types: Boxy (rotating layered boxes), Sphere minus box, or Heightmap. Parameters control layers, zoom/pan, base color, edge darkening, glow, and light direction. Connect UV (e.g. from UV Coords); output is vec4 for final output or blending.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "UV coordinates (e.g. from UV Coords)",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "RGBA color; connect to Final Output or blend with other nodes",
          "suggestedTargets": [
            "node:final-output",
            "node:blend-mode",
            "node:mix",
            "node:glow-bloom"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "hex-voxel" },
          { "id": "c", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:box-torus-sdf",
        "node:sphere-raymarch",
        "node:bloom-sphere",
        "node:hexagonal-grid",
        "type:vec2",
        "type:vec4"
      ],
      "examples": [
        "Connect UV to in; output to Final Output or Mix for a 3D voxel view with hex-grid slices and optional glow.",
        "Use Yaw and Pitch to orbit the view; switch shape type (Boxy, Sphere minus box, Heightmap) for different voxel looks.",
        "Layer with Color Map or Blend Mode for tinting; adjust layers and zoom for depth and scale."
      ],
      "advanced": "Uses a painter's-algorithm composite (front-to-back) and an IQ-style hex coordinate system; the built-in 3D SDF is sampled at voxel positions. View is independent on both axes (yaw/pitch)."
    },
    "node:volume-rays": {
      "title": "Volume Rays",
      "titleType": "node",
      "tagline": "Accumulates glow and density along the view ray using raymarching and 3D noise",
      "description": "Marches a ray from the camera through the UV and accumulates density (3D value noise) along the ray to produce a volumetric glow. Camera position (X, Y, Z), yaw (left/right), and pitch (up/down) control the view; FOV Scale zooms in or widens the view. Control raymarch steps and step size, density scale, and output intensity. Ideal for fog, light shafts, or abstract volumetric effects.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Input UV coordinates to raymarch from",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "Accumulated density/glow (float)",
          "suggestedTargets": [
            "node:color-map",
            "node:mix",
            "node:multiply",
            "node:smoothstep"
          ]
        }
      ],
      "relatedItems": [
        "node:sphere-raymarch",
        "node:noise",
        "node:gradient",
        "type:vec2"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "volume-rays" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV → Volume Rays → Color Map for fog, light shafts, or volumetric glow.",
        "Adjust camera yaw/pitch and FOV for view; tune density scale and steps for thickness.",
        "Combine with Gradient or Noise for layered volumetric effects."
      ],
      "advanced": "Raymarches through 3D noise to accumulate density; more steps add quality but cost. Use for god rays, fog, or abstract volume."
    },
    "node:streak": {
      "title": "Streak",
      "titleType": "node",
      "tagline": "Directional streak or anamorphic overlay with angle, stretch, and intensity",
      "description": "Produces a 2D directional streak (anamorphic-style) from the input coordinates. The streak direction is set by angle; width controls the gaussian falloff perpendicular to the streak; stretch controls how far along the streak the falloff extends. Use with mix or multiply to overlay on existing content.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Input 2D coordinates (e.g. UV)",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "Streak intensity (float)",
          "suggestedTargets": [
            "node:color-map",
            "node:mix",
            "node:multiply",
            "node:blend-mode"
          ]
        }
      ],
      "relatedItems": [
        "node:gradient",
        "node:rings",
        "node:polar-coordinates",
        "type:vec2"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "streak" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV → Streak → Mix (with another pattern) for anamorphic or directional streak overlay.",
        "Set angle for streak direction; tune width and stretch for thin or broad streaks.",
        "Use with Color Map for standalone streak, or Multiply for lens-flare style."
      ],
      "advanced": "Directional gaussian streak; angle sets direction, width/stretch set shape. Use for anamorphic bokeh or light streaks."
    },
    "node:shapes-2d": {
      "title": "Shapes",
      "titleType": "node",
      "tagline": "Circle (or ellipse) and square (or rounded box) as SDF mask; aspect from size",
      "description": "Outputs a 2D shape as a float mask: choose Circle or Square. Size is width and height; unequal width/height gives an ellipse or rectangle. Roundness only affects Square (rounded corners). Use center to position, softness for edge blur, and intensity to scale the output. Ideal for vignettes, panels, and composite shapes with mix or color-map.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Input 2D coordinates (e.g. UV)",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "Mask value: 1.0 inside shape, 0.0 outside, soft transition at edge",
          "suggestedTargets": [
            "node:mix",
            "node:smoothstep",
            "node:color-map",
            "node:multiply"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "shapes-2d" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:rings",
        "node:distance",
        "node:box-torus-sdf",
        "type:vec2"
      ],
      "examples": [
        "Connect UV to in; feed output to Color Map or Mix for circles, ellipses, or rounded squares as masks or panels.",
        "Use unequal width/height for ellipses or rectangles; roundness (Square mode) for soft corners on panels.",
        "Combine with other masks (e.g. Starburst, Star) via Mix or Multiply for composite shapes and vignettes."
      ],
      "advanced": "SDF (signed distance function) gives a smooth mask: positive inside, negative outside. Circle vs Square and size control aspect; softness blurs the edge."
    },
    "node:star-2d": {
      "title": "Starburst",
      "titleType": "node",
      "tagline": "N-point star shape with inner/outer radius and optional rounded corners",
      "description": "Outputs a 2D star as a float mask using an SDF. You control the number of points, inner and outer radius (for pointed or stubby stars), and optional roundness for softer corners. Softness and intensity adjust the edge and strength. Ideal for badges, decorative shapes, and masks when combined with color map or mix.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Input 2D coordinates (e.g. UV)",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "Mask value: 1.0 inside star, 0.0 outside, soft transition at edge",
          "suggestedTargets": [
            "node:mix",
            "node:smoothstep",
            "node:color-map",
            "node:multiply"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "star-2d" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:shapes-2d",
        "node:superellipse",
        "type:vec2"
      ]
    },
    "node:star-shape-2d": {
      "title": "Star",
      "titleType": "node",
      "tagline": "N-point star shape with inner/outer radius, rotation, and softness for masks and patterns.",
      "description": "Outputs a 2D star as a float using an SDF. You control the number of points, inner and outer radius, roundness, rotation, and softness. Connect UV (or translated coordinates) to the input; use the output with Color Map or Mix for badges, decorative shapes, or masks. Parameters: Center X/Y, Points, Inner/Outer Radius, Roundness, Rotation, Softness, Intensity.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Position to sample (e.g. UV coordinates)",
          "suggestedSources": ["type:vec2", "node:uv-coordinates", "node:translate", "node:scale"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "Star shape value; use with color-map or mix for visible result",
          "suggestedTargets": ["node:color-map", "node:mix", "node:smoothstep", "node:multiply"]
        }
      ],
      "parameters": [
        { "name": "Center X", "description": "Horizontal center of the star in UV space. 0.5 = center of screen; change to move the star left or right." },
        { "name": "Center Y", "description": "Vertical center of the star in UV space. 0.5 = center of screen; change to move the star up or down." },
        { "name": "Points", "description": "Number of star points (3–32). More points = spikier star; fewer = simpler shape." },
        { "name": "Inner Radius", "description": "Radius of the inner star points; smaller = pointier star, larger = rounder center." },
        { "name": "Outer Radius", "description": "Radius of the outer star tips. Larger = bigger star on screen." },
        { "name": "Roundness", "description": "Softens the inner corners (0 = sharp, 1 = round). Higher = smoother indent between points." },
        { "name": "Rotation", "description": "Rotation angle of the star in degrees. Change to spin the star without moving its center." },
        { "name": "Softness", "description": "Edge softness of the shape. Higher = smoother transition from inside to outside; lower = crisper edge." },
        { "name": "Intensity", "description": "Strength of the output value. Higher = brighter shape when connected to Color Map or Mix." }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "star-shape-2d" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "relatedItems": ["node:shapes-2d", "node:star-2d", "node:superellipse", "type:vec2"]
    },
    "node:superellipse": {
      "title": "Super",
      "titleType": "node",
      "tagline": "Squircle to rectangle: power parameter controls shape from ellipse to rounded rect",
      "description": "Outputs a superellipse as a float mask. The power parameter (n) controls the shape: 2 gives an ellipse, higher values approach a rectangle with rounded corners (squircle). Radius X and Y set the half-axes. Use softness and intensity for edge and strength. Ideal for modern UI-style shapes and masks.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Input 2D coordinates (e.g. UV)",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "Mask value: 1.0 inside superellipse, 0.0 outside, soft transition at edge",
          "suggestedTargets": [
            "node:mix",
            "node:smoothstep",
            "node:color-map",
            "node:multiply"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "superellipse" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:shapes-2d",
        "node:star-2d",
        "type:vec2"
      ]
    },
    "node:fractal": {
      "title": "Fractal",
      "titleType": "node",
      "tagline": "Perfect for generating complex fractal patterns with self-similar structures at multiple scales",
      "description": "Generates fractal patterns by iteratively applying transformations and combining results at different scales. Fractals exhibit self-similarity, meaning patterns repeat at different scales, creating complex, organic-looking structures. The node uses iterative algorithms to create these patterns, with configurable iterations, scale factors, and transformation parameters. Fractals are ideal for creating natural-looking patterns, abstract art, or complex geometric structures that would be difficult to create manually.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input UV coordinates to generate the fractal pattern from"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The fractal pattern value"
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "fractal" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:noise",
        "node:turbulence",
        "type:vec2",
        "node:time"
      ],
      "examples": [
        "Connect UV to in; feed output to Color Map for self-similar patterns at multiple scales.",
        "Drive iterations and scale from Time or constants for animated or static fractal detail.",
        "Combine with Noise or Turbulence via Mix for organic, natural-looking backgrounds."
      ],
      "advanced": "Fractals repeat the same transformation at different scales; more iterations add detail but cost performance. Use for organic or abstract patterns that are hard to achieve with simple noise."
    },
    "node:voronoi-noise": {
      "title": "Voronoi Noise",
      "titleType": "node",
      "tagline": "Ideal for creating cellular patterns and organic-looking textures with distinct regions",
      "description": "Generates Voronoi (cellular) noise patterns by dividing space into regions based on proximity to seed points. Each region contains all points closest to a particular seed, creating distinct cellular structures. Output mode: 0 = F1 (distance to nearest seed), 1 = F2−F1 (difference to second-nearest), 2 = edge (smooth edge between cells), 3 = cell ID (normalized hash per cell). Animation: choose Drift (direction and amount), Rotate (UV rotation), or Still. Use Drift Direction (degrees) and Drift Amount for directional flow; Rotation Speed when in Rotate mode.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input UV coordinates to sample the Voronoi pattern"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "Voronoi value: F1, F2−F1, edge, or cell ID depending on Output mode"
        }
      ],
      "relatedItems": [
        "node:worley-noise",
        "node:noise",
        "node:noise",
        "node:distance",
        "type:vec2",
        "node:time"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "voronoi-noise" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV → Voronoi → Color Map for cellular patterns; choose F1, F2−F1, edge, or cell ID mode.",
        "Use Drift or Rotate animation for flowing cells; scale controls cell size.",
        "Combine with Noise or Worley via Mix for organic plus cellular texture."
      ],
      "advanced": "Voronoi seeds partition space; F1 is distance to nearest, F2−F1 gives ridges, edge smooths boundaries. Use for cells, scales, or organic regions."
    },
    "node:worley-noise": {
      "title": "Worley Noise",
      "titleType": "node",
      "tagline": "Cellular noise with F1, F2−F1, or edge output for organic and crystal-like patterns",
      "description": "Generates Worley (cellular) noise using the same grid-and-jitter structure as Voronoi. Output mode: F1 (distance to nearest point), F2−F1 (difference to second-nearest), or edge (smooth cell boundaries). Use for organic textures, scales, or abstract cellular patterns. Scale, jitter, and distance metric (Euclidean, Manhattan, Chebyshev) are in the Worley group; output mode and intensity in Output.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input UV coordinates to sample the Worley pattern"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "Worley value: F1, F2−F1, or edge depending on Output mode"
        }
      ],
      "relatedItems": [
        "node:voronoi-noise",
        "node:noise",
        "type:vec2",
        "node:time"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "worley-noise" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV → Worley → Color Map for cellular or crystal-like patterns; pick F1, F2−F1, or edge.",
        "Tune scale and jitter for cell size and regularity; try Manhattan or Chebyshev for different shapes.",
        "Layer with Voronoi or Noise for mixed organic and cellular looks."
      ],
      "advanced": "Same grid-and-jitter structure as Voronoi; distance metric (Euclidean, Manhattan, Chebyshev) changes cell shape. Use for scales, crystals, or abstract cells."
    },
    "node:wave-patterns": {
      "title": "Wave Patterns",
      "titleType": "node",
      "tagline": "Perfect for creating animated wave patterns with customizable frequency, amplitude, and direction",
      "description": "Generates wave patterns using trigonometric functions (sine, cosine) to create repeating, oscillating patterns. The waves can be oriented in different directions, have configurable frequency (how many waves), amplitude (wave height), and can be animated over time. Multiple wave layers can be combined to create complex interference patterns. This is ideal for creating water effects, animated backgrounds, or any repeating wave-like patterns. The waves can be linear (traveling in one direction) or radial (expanding from a center point).",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input UV coordinates to generate waves from",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale",
            "node:time"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The wave pattern value (typically -1.0 to 1.0 range)",
          "suggestedTargets": [
            "node:color-map",
            "node:mix",
            "node:smoothstep",
            "node:translate",
            "node:blending-modes"
          ]
        }
      ],
      "relatedItems": [
        "node:sine",
        "node:cosine",
        "node:time",
        "type:vec2"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "wave-patterns" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV → Wave Patterns → Color Map for sine/cosine waves; animate with time for moving waves.",
        "Use linear mode for directional waves or radial for circular; combine layers for interference.",
        "Feed into Mix or Smoothstep for wave-based masks or distortion."
      ],
      "advanced": "Trig-based waves (sine/cosine); frequency and amplitude set count and strength. Use linear for stripes, radial for ripples from center."
    },
    "node:flow-field-pattern": {
      "title": "Flow Field",
      "titleType": "node",
      "tagline": "Curl-noise-based flow pattern for organic streaks and flow lines",
      "description": "Generates a flow-like pattern using 2D curl noise: the curl of a scalar noise field gives a divergence-free vector field, whose magnitude is mapped to a 0–1 float suitable for color mapping. Parameters control spatial scale, curl sampling scale, time speed, octaves, and output intensity. Ideal for organic, fluid-like backgrounds and streak effects.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Input UV coordinates to sample the flow field",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale",
            "node:domain-repetition"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "Flow pattern value (0–1 range) for color map or mixing",
          "suggestedTargets": [
            "node:color-map",
            "node:mix",
            "node:smoothstep"
          ]
        }
      ],
      "relatedItems": [
        "node:noise",
        "node:noise",
        "node:vector-field",
        "type:float"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "flow-field-pattern" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV → Flow Field → Color Map for organic flow streaks; tune scale and time speed.",
        "Use with Domain Repetition for tiled flow; combine with Curl Noise for layered flow.",
        "Feed into Mix or Smoothstep for flow-based masks."
      ],
      "advanced": "Curl-noise magnitude mapped to 0–1; divergence-free so flow lines don't converge. Use for fluid-like or organic streak backgrounds."
    },
    "node:stripes": {
      "title": "Stripes",
      "titleType": "node",
      "tagline": "Directional alternating bands with configurable angle, frequency, and sharp or soft edges",
      "description": "Generates directional stripe patterns by rotating the input coordinates and creating alternating bands along one axis. Control the stripe angle (direction), frequency (number of bands), and sharpness (0 for soft gradients, 1 for hard edges). Optional phase and time speed allow animation when time is wired from the graph. Output is a float suitable for color map or mix.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input UV coordinates to generate stripes from",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale",
            "node:rotate"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The stripe pattern value (0.0 to 1.0)",
          "suggestedTargets": [
            "node:color-map",
            "node:mix",
            "node:smoothstep",
            "node:gradient-mask"
          ]
        }
      ],
      "relatedItems": [
        "node:wave-patterns",
        "node:dots",
        "node:rings",
        "type:vec2"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "stripes" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV → Stripes → Color Map for alternating bands; set angle and frequency for direction and count.",
        "Use sharpness 0 for soft gradients, 1 for hard edges; animate phase with Time.",
        "Combine with Wave Patterns or Dots via Mix for combined patterns."
      ],
      "advanced": "Rotates coords then repeats along one axis; sharpness controls edge softness. Use for zebra stripes, scanlines, or directional bands."
    },
    "node:dots": {
      "title": "Dots",
      "titleType": "node",
      "tagline": "Polka-dot grid pattern with configurable spacing, dot size, and falloff",
      "description": "Generates a seamless grid of dots (polka-dot pattern) by tiling the plane and drawing a circular dot in each cell. Control the spacing between dots, the dot size (radius), and the falloff (softness of the edge). The pattern tiles seamlessly and outputs a float suitable for color map or mix.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input UV coordinates to generate the dot grid from",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The dot pattern value (0.0 to 1.0)",
          "suggestedTargets": [
            "node:color-map",
            "node:mix",
            "node:smoothstep",
            "node:gradient-mask"
          ]
        }
      ],
      "relatedItems": [
        "node:stripes",
        "node:hexagonal-grid",
        "node:plane-grid",
        "type:vec2"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "dots" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV → Dots → Color Map for polka-dot grid; tune spacing and dot size for density.",
        "Use with Domain Repetition or Brick Tiling for offset dot layouts.",
        "Soften falloff for blurred dots or use with Mix for spot patterns."
      ],
      "advanced": "Seamless grid of circular dots; spacing and radius set layout. Use for fabric, bubbles, or regular spot patterns."
    },
    "node:reaction-diffusion": {
      "title": "Reaction-Diffusion",
      "titleType": "node",
      "tagline": "Gray-Scott-inspired cell and spot pattern (single-pass approximation)",
      "description": "Generates an R-D-like cell/spot pattern using Gray-Scott equations with a spot-based seed and 1–5 steps per pixel (single-pass). Feed and Kill (0.01–0.15), Diff A (0.2–4) and Diff B (0.05–1.5) use wider ranges for exploration. Time speed 0–5 scales animation linearly; Grain adds variation. True R-D requires many iterations; this approximates the look. Output float 0–1 for color map or mix.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input UV coordinates to sample the pattern",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The pattern value (0.0 to 1.0)",
          "suggestedTargets": [
            "node:color-map",
            "node:mix",
            "node:gradient-mask"
          ]
        }
      ],
      "relatedItems": [
        "node:voronoi-noise",
        "node:noise",
        "node:gradient",
        "type:vec2"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "reaction-diffusion" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV → Reaction-Diffusion → Color Map for Gray-Scott-style cells or spots; tune Feed/Kill and Diff.",
        "Animate with time speed for evolving patterns; add Grain for variation.",
        "Single-pass approximation; use for organic cells or spotted textures."
      ],
      "advanced": "Gray-Scott R-D with limited steps per pixel; true R-D needs many iterations. Feed/Kill and diffusion rates control spot vs stripe vs labyrinth."
    },
    "node:gradient": {
      "title": "Gradient",
      "titleType": "node",
      "tagline": "Radial or linear gradient (float 0–1) for vignettes, orbs, and linear fades",
      "description": "Outputs a single float gradient in 0–1 range. Radial mode: gradient from center with configurable radius and falloff (smoothstep). Linear mode: gradient along an angle with scale. Use with color map, mix, or smoothstep for vignettes, orbs, and directional fades.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input UV coordinates to sample the gradient",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale",
            "node:rotate"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The gradient value (0.0 to 1.0)",
          "suggestedTargets": [
            "node:mix",
            "node:color-map",
            "node:final-output",
            "node:smoothstep"
          ]
        }
      ],
      "relatedItems": [
        "node:rings",
        "node:distance",
        "node:smoothstep",
        "type:vec2"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "gradient" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV → Gradient → Color Map or Mix for radial vignette or linear fade; set radius and falloff.",
        "Use radial for orbs and vignettes; linear for directional fades or sweeps.",
        "Combine with Rings or Distance for blended radial effects."
      ],
      "advanced": "Single float 0–1; radial uses distance from center with smoothstep falloff. Linear uses angle and scale for directional gradient."
    },
    "node:hash32": {
      "title": "Hash32",
      "titleType": "node",
      "tagline": "Deterministic vec3 from vec2 for per-cell colors and procedural variation",
      "description": "Maps a vec2 (e.g. cell id or UV) to a deterministic vec3 in [0,1] using a Dave Hoskins–style hash (reference: Shadertoy 4djSRW). Useful for disco-style patterns, Voronoi-like cell coloring, and any effect that needs a stable RGB from 2D coordinates.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Input 2D coordinates (e.g. cell id or UV)",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale",
            "node:floor",
            "node:fragment-coordinates"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec3",
          "description": "Deterministic RGB in [0,1]",
          "suggestedTargets": [
            "node:color-map",
            "node:final-output",
            "node:disco-pattern",
            "node:mix"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "uv-coordinates" },
          { "id": "n2", "type": "hash32" },
          { "id": "n3", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n2", "toPort": "in" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:fract",
        "node:voronoi-noise",
        "type:vec3",
        "type:vec2"
      ]
    },
    "node:disco-pattern": {
      "title": "Disco Pattern",
      "titleType": "node",
      "tagline": "Diamond-grid pattern with per-cell hash color and edge for layered disco-style effects",
      "description": "Outputs vec4(RGB, edge): RGB is a deterministic hash color per diagonal cell, alpha is the diamond edge term (0 at edges, 1 at cell centers). Scale and phase parameters let you layer multiple instances with different Scale/Translate for the reference 4-layer multiply look. Connect .rgb (e.g. via Swizzle) to Final Output or Color Map.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Input UV coordinates (e.g. from Scale/Translate)",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "RGB = per-cell hash color, A = diamond edge (0–1)",
          "suggestedTargets": [
            "node:swizzle",
            "node:color-map",
            "node:mix",
            "node:blending-modes"
          ]
        }
      ],
      "relatedItems": [
        "node:hash32",
        "node:voronoi-noise",
        "node:wave-patterns",
        "type:vec4",
        "type:vec2"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "disco-pattern" },
          { "id": "c", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV → Disco Pattern → Final Output (or Mix) for diamond/cell pattern with per-cell color.",
        "Output RGB is hash color per cell, A is diamond edge; use with Blend Mode or Swizzle for variation.",
        "Combine with Voronoi or Wave Patterns for layered disco or retro looks."
      ],
      "advanced": "Per-cell hash gives stable color per diamond; alpha gives edge. Use for disco, confetti, or cell-based color without full Voronoi."
    },
    "node:radial-rays": {
      "title": "Radial Rays",
      "titleType": "node",
      "tagline": "N rays from a center point with count, spread, width, and falloff",
      "description": "Generates a radial ray pattern: N evenly spaced rays emanating from a center point. Control ray count, angular spread (full circle or arc), ray width, edge falloff, and rotation. Output is a float suitable for blending or mixing with color maps. Ideal for sunbursts, starbursts, and radial light effects.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Input 2D coordinates (e.g. UV)",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale",
            "node:rotate"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "Ray pattern value (0.0 to 1.0)",
          "suggestedTargets": [
            "node:color-map",
            "node:mix",
            "node:multiply",
            "node:blend-mode"
          ]
        }
      ],
      "relatedItems": [
        "node:sunbeams",
        "node:crepuscular-rays",
        "node:rings",
        "node:polar-coordinates",
        "type:vec2"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "radial-rays" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV → Radial Rays → Color Map or Mix for sunburst or starburst; set count and spread.",
        "Use with Polar Coords for radial layout; tune width and falloff for sharp or soft rays.",
        "Combine with Sunbeams or Crepuscular Rays for layered light effects."
      ],
      "advanced": "N rays from a center; spread can be full circle or arc. Use for sunbursts, starbursts, or radial masks."
    },
    "node:sunbeams": {
      "title": "Sunbeams",
      "titleType": "node",
      "tagline": "Directional beams at an angle for light streaks and god-ray style effects",
      "description": "Produces directional parallel beams at a configurable angle. Control beam count, spread (frequency along the perpendicular axis), width, softness, and intensity. Output is a float for blending. Use with mix or multiply for sunbeam overlays and directional light streaks.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Input 2D coordinates (e.g. UV)",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "Beam pattern value (0.0 to 1.0)",
          "suggestedTargets": [
            "node:color-map",
            "node:mix",
            "node:multiply",
            "node:blend-mode"
          ]
        }
      ],
      "relatedItems": [
        "node:radial-rays",
        "node:crepuscular-rays",
        "node:gradient",
        "node:streak",
        "type:vec2"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "sunbeams" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV → Sunbeams → Mix for directional light streaks; set angle and beam count.",
        "Use with Blend Mode or Multiply for god-ray overlay on existing content.",
        "Tune width and softness for thin or broad beams."
      ],
      "advanced": "Parallel beams at one angle; use for directional sunbeams. For rays from a point use Radial Rays or Crepuscular Rays."
    },
    "node:crepuscular-rays": {
      "title": "Crepuscular Rays",
      "titleType": "node",
      "tagline": "Atmospheric rays from a source point with distance falloff",
      "description": "Generates crepuscular (atmospheric) rays from a source point. Rays radiate from the source with configurable count, spread, and width. Distance falloff attenuates the rays with distance from the source (1/(1 + dist*k)), giving a natural volumetric look. Animation: rotation speed (turns per second) and rotation offset (phase in turns) for continuous rotating rays. Ideal for sun-through-clouds and god-ray effects.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Input 2D coordinates (e.g. UV)",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "Ray pattern value with distance falloff (0.0 to 1.0)",
          "suggestedTargets": [
            "node:color-map",
            "node:mix",
            "node:multiply",
            "node:blend-mode"
          ]
        }
      ],
      "relatedItems": [
        "node:radial-rays",
        "node:sunbeams",
        "node:gradient",
        "node:rings",
        "type:vec2"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "crepuscular-rays" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV → Crepuscular Rays → Color Map or Mix for rays from a source point with distance falloff.",
        "Set source position for origin; tune count, spread, and falloff for volumetric look.",
        "Animate rotation speed for rotating rays; use for sun-through-clouds or god rays."
      ],
      "advanced": "Rays from a point with 1/(1+dist*k) falloff for natural attenuation. Use for atmospheric rays; rotation animates the ray direction."
    },
    "node:gradient-mask": {
      "title": "Gradient Mask",
      "titleType": "node",
      "tagline": "Ideal for creating smooth gradient masks for selective effect application and blending",
      "description": "Creates gradient masks that can selectively apply or blend effects in specific regions. The node supports multiple mask types: radial (circular gradients from a center point), linear (gradients along a direction), and elliptical (oval-shaped gradients). Each mask type has configurable position, size, falloff, and strength parameters. The mask outputs a value from 0.0 (fully masked) to 1.0 (fully visible), allowing smooth transitions. This is essential for creating vignettes, spotlight effects, or any region-based effect application.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "The input color to apply the gradient mask to",
          "suggestedSources": [
            "node:color-map",
            "node:oklch-color-map-bezier",
            "node:mix",
            "node:blend-mode"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The masked color output with gradient blending applied",
          "suggestedTargets": [
            "node:final-output",
            "node:mix",
            "node:blend-mode",
            "node:glow-bloom"
          ]
        }
      ],
      "relatedItems": [
        "node:compare",
        "node:select",
        "type:vec4",
        "node:distance"
      ]
    },
    "node:hexagonal-grid": {
      "title": "Hexagons",
      "titleType": "node",
      "tagline": "Perfect for creating hexagonal grid patterns for tiling, cellular structures, or game board layouts",
      "description": "Generates a seamless, regular hexagonal tiling pattern. Control the cell size, the gap (margin) between cells, and a per-cell rotation (rotates each hexagon’s shape without rotating the grid). A separate grid rotation rotates the overall tiling, and intensity controls the output strength.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input UV coordinates to generate the hexagonal grid from",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale",
            "node:rotate"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The hexagonal grid pattern value",
          "suggestedTargets": [
            "node:color-map",
            "node:mix",
            "node:smoothstep",
            "node:gradient-mask"
          ]
        }
      ],
      "relatedItems": [
        "node:plane-grid",
        "node:fract",
        "type:vec2"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "hexagonal-grid" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV → Hexagonal Grid → Color Map for honeycomb or tiled hexagons; tune cell size and gap.",
        "Use with Domain Repetition or Scale for more tiles; per-cell rotation for twisted hexes.",
        "Combine with Noise or Rings via Mix for organic or radial hex patterns."
      ],
      "advanced": "Seamless hex tiling; gap sets margin between cells. Grid rotation and per-cell rotation give layout variety. Use for game boards, cells, or tessellation."
    },
    "node:hex-prism-sdf": {
      "title": "Hex 3D",
      "titleType": "node",
      "tagline": "3D SDF primitive: extruded hexagon for raymarching",
      "description": "Outputs a signed distance field (SDF) for a hex prism (extruded hexagon). Connect a vec3 position (e.g. from a raymarcher); the output is a float SDF suitable for the generic raymarcher or repeated-hex-prism-sdf. Hex radius controls the cross-section size; half height controls the extrusion. Reference: Shadertoy hex-prism raymarch.",
      "inputs": [
        {
          "name": "position",
          "type": "vec3",
          "description": "3D position to evaluate the SDF at (e.g. raymarch sample point)",
          "suggestedSources": [
            "type:vec3",
            "node:constant-vec3"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "Signed distance to the hex prism surface",
          "suggestedTargets": [
            "node:generic-raymarcher",
            "node:repeated-hex-prism-sdf",
            "node:mix",
            "node:smoothstep",
            "node:color-map"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "orbit-camera" },
          { "id": "c", "type": "hex-prism-sdf" },
          { "id": "d", "type": "generic-raymarcher" },
          { "id": "e", "type": "color-map" },
          { "id": "f", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "ro", "to": "d", "toPort": "ro" },
          { "from": "b", "fromPort": "rd", "to": "d", "toPort": "rd" },
          { "from": "a", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "sdf" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" },
          { "from": "e", "fromPort": "out", "to": "f", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:generic-raymarcher",
        "node:repeated-hex-prism-sdf",
        "node:radial-repeat-sdf",
        "node:box-torus-sdf",
        "type:vec3",
        "node:constant-vec3"
      ],
      "examples": [
        "Connect this node's out to Generic SDF Raymarcher sdf; connect Orbit Camera ro/rd and UV to the raymarcher for a single hex prism.",
        "Typical use: Camera ro/rd and UV → Generic SDF Raymarcher; this node (position from raymarcher) → raymarcher sdf → Color Map.",
        "Use hex radius and half-height to shape the prism; feed into Repeated 3D Hex for an infinite grid of hex prisms."
      ],
      "advanced": "Output is a signed distance to the hex prism (extruded hexagon). The raymarcher evaluates this at each step; position is in world space. For tiling, use Repeated 3D Hex instead."
    },
    "node:repeated-hex-prism-sdf": {
      "title": "Repeated 3D Hex",
      "titleType": "node",
      "tagline": "3D SDF: infinite grid of hex prisms for raymarching",
      "description": "Outputs a signed distance field (SDF) for an infinite 3D grid of hex prisms. Uses domain repetition (mod(p, spacing) - 0.5*spacing) then the hex prism SDF. Connect a vec3 position (e.g. from the generic raymarcher); the output is a float SDF. Parameters: spacing X/Y/Z, hex radius, half-height. Reference: Shadertoy hex-prism raymarch.",
      "inputs": [
        {
          "name": "position",
          "type": "vec3",
          "description": "3D position to evaluate the SDF at (e.g. raymarch sample point)",
          "suggestedSources": [
            "type:vec3",
            "node:constant-vec3"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "Signed distance to the repeated hex prism grid",
          "suggestedTargets": [
            "node:generic-raymarcher",
            "node:mix",
            "node:smoothstep",
            "node:color-map"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "orbit-camera" },
          { "id": "c", "type": "repeated-hex-prism-sdf" },
          { "id": "d", "type": "generic-raymarcher" },
          { "id": "e", "type": "color-map" },
          { "id": "f", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "ro", "to": "d", "toPort": "ro" },
          { "from": "b", "fromPort": "rd", "to": "d", "toPort": "rd" },
          { "from": "a", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "sdf" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" },
          { "from": "e", "fromPort": "out", "to": "f", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:hex-prism-sdf",
        "node:generic-raymarcher",
        "node:radial-repeat-sdf",
        "node:box-torus-sdf",
        "type:vec3",
        "node:constant-vec3"
      ]
    },
    "node:particle-system": {
      "title": "Particle System",
      "titleType": "node",
      "tagline": "Perfect for creating animated particle effects with configurable movement, size, and behavior",
      "description": "Generates animated particle systems that create dynamic, moving particle effects. Each particle has position, velocity, size, and lifetime properties that evolve over time. The particles can be rendered as points, circles, or other shapes, and can interact with forces, boundaries, or other particles. The system supports configurable particle count, spawn rate, initial velocity, gravity, and various behaviors. This is ideal for creating effects like sparks, smoke, rain, or any collection of moving elements.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input UV coordinates to render particles at"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The particle system output (particle presence or density)"
        }
      ],
      "relatedItems": [
        "node:time",
        "node:distance",
        "type:vec2"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "particle-system" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "examples": [
        "Connect UV → Particle System → Color Map for animated particles; drive with Time for motion.",
        "Tune count, size, and behavior for sparks, rain, or abstract motion.",
        "Combine with Distance or other patterns for particle density or masking."
      ],
      "advanced": "Particles have position, velocity, size, lifetime; configurable spawn and forces. Use for sparks, smoke, rain, or any moving point set."
    },
    "node:plane-grid": {
      "title": "Grid",
      "titleType": "node",
      "tagline": "Ideal for creating regular square grid patterns for tiling, organization, or structural elements",
      "description": "Generates regular square grid patterns by dividing space into uniform cells. The grid creates a checkerboard or lattice-like pattern that can be used for tiling, organization, or as a structural element in compositions. You can control the grid cell size, line thickness, and offset. The grid can output cell IDs, distance to grid lines, or edge detection. This is useful for creating game boards, measurement grids, or any application requiring regular spatial division.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input UV coordinates to generate the grid from"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The grid pattern value"
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "plane-grid" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:hexagonal-grid",
        "node:fract",
        "type:vec2"
      ]
    },
    "node:box-torus-sdf": {
      "title": "Primitives",
      "titleType": "node",
      "tagline": "3D primitives (box, torus, capsule, cylinder, cone, round cone, octahedron, icosahedron) using signed distance fields and raymarching",
      "description": "Renders 3D primitives using signed distance fields (SDF) with raymarching. Shape types: 0=Box, 1=Torus, 2=Capsule, 3=Cylinder (capped; radius X, half-height Y), 4=Cone (height Y, base radius X, top radius Z), 5=Round cone (base X, tip radius Z, height Y), 6=Octahedron (scale X), 7=Icosahedron (scale X). All share Position, Size, Rotation, and Appearance (glow, raymarch steps). Lighting supports directional or point light with optional shadows. Specular group: enable Cook-Torrance (GGX + Fresnel) for PBR-style specular; Roughness and F0 control the look. Optional Ray origin and Ray direction: when connected (e.g. from Orbit Camera), the node uses that camera; when unconnected, uses the built-in fixed camera.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input UV coordinates to raymarch from"
        },
        {
          "name": "ro",
          "type": "vec3",
          "description": "Ray origin (camera position); when unconnected, uses Ro X/Y/Z parameters",
          "suggestedSources": [
            "node:orbit-camera"
          ]
        },
        {
          "name": "rd",
          "type": "vec3",
          "description": "Ray direction; when unconnected, built from UV for perspective",
          "suggestedSources": [
            "node:orbit-camera"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The SDF raymarched shape result (signed distance value)"
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "orbit-camera" },
          { "id": "c", "type": "box-torus-sdf" },
          { "id": "d", "type": "color-map" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "ro", "to": "c", "toPort": "ro" },
          { "from": "b", "fromPort": "rd", "to": "c", "toPort": "rd" },
          { "from": "a", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:orbit-camera",
        "node:sphere-raymarch",
        "node:glass-shell",
        "node:distance",
        "type:vec2",
        "node:normalize"
      ],
      "examples": [
        "Connect Look-at Camera or Orbit Camera ro/rd to ro/rd inputs; connect UV to in, then output to Color Map or Final Output.",
        "Switch shape type (Box, Torus, Capsule, Cylinder, Cone, Octahedron, Icosahedron) for different primitives; use Size and Rotation to pose.",
        "Enable Cook-Torrance in Specular for PBR-style reflections; add directional or point light and optional shadows."
      ],
      "advanced": "When ro/rd are unconnected, the node uses a built-in fixed camera. For consistent camera across multiple 3D nodes, connect one Orbit Camera or Look-at Camera to all. SDF combination order (if you later combine with other SDFs) affects which shape is in front."
    },
    "node:glass-shell": {
      "title": "Glass Shell",
      "titleType": "node",
      "tagline": "Refractive glass shell: outer SDF → refract → inner SDF → shade; object inside glass effect",
      "description": "Two-stage raymarch: march outer SDF (sphere, box, or icosahedron), at hit refract the ray with IOR, then march inner SDF (sphere, box, or smooth blend). Shades the inner hit with diffuse and optional Cook-Torrance specular, or uses background color if inner ray misses. Adds outer specular on the glass surface. Output is vec4 for Final Output or blending. Optional ro/rd inputs: connect Orbit Camera for shared camera; when unconnected, uses built-in camera (Ro X/Y/Z).",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "UV coordinates (e.g. from UV Coords) to raymarch from",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale"
          ]
        },
        {
          "name": "ro",
          "type": "vec3",
          "description": "Ray origin (camera position); when unconnected, uses Ro X/Y/Z parameters",
          "suggestedSources": [
            "node:orbit-camera"
          ]
        },
        {
          "name": "rd",
          "type": "vec3",
          "description": "Ray direction; when unconnected, built from UV for perspective",
          "suggestedSources": [
            "node:orbit-camera"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "RGBA color; connect to Final Output or blend with other nodes",
          "suggestedTargets": [
            "node:final-output",
            "node:blend-mode",
            "node:mix",
            "node:glow-bloom"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "orbit-camera" },
          { "id": "c", "type": "glass-shell" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "ro", "to": "c", "toPort": "ro" },
          { "from": "b", "fromPort": "rd", "to": "c", "toPort": "rd" },
          { "from": "a", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:box-torus-sdf",
        "node:orbit-camera",
        "node:sphere-raymarch",
        "node:bloom-sphere",
        "type:vec2",
        "type:vec4"
      ]
    },
    "node:radial-repeat-sdf": {
      "title": "Radial Repeat SDF",
      "titleType": "node",
      "tagline": "3D SDF primitive: concentric spherical shells for Shadertoy-style raymarching",
      "description": "Outputs a signed distance field (SDF) for concentric spherical shells: abs(mod(length(p), period) - halfPeriod). Connect a vec3 position (e.g. from a raymarcher or 3D position node); the output is a float SDF suitable for the generic raymarcher or other SDF composition. Period controls the spacing between shells; half period sets the shell thickness. Composable primitive for building raymarched scenes.",
      "inputs": [
        {
          "name": "position",
          "type": "vec3",
          "description": "3D position to evaluate the SDF at (e.g. raymarch sample point)",
          "suggestedSources": [
            "type:vec3",
            "node:constant-vec3"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "Signed distance to the concentric shells",
          "suggestedTargets": [
            "node:generic-raymarcher",
            "node:mix",
            "node:smoothstep",
            "node:color-map"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "orbit-camera" },
          { "id": "c", "type": "radial-repeat-sdf" },
          { "id": "d", "type": "generic-raymarcher" },
          { "id": "e", "type": "color-map" },
          { "id": "f", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "ro", "to": "d", "toPort": "ro" },
          { "from": "b", "fromPort": "rd", "to": "d", "toPort": "rd" },
          { "from": "a", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "sdf" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" },
          { "from": "e", "fromPort": "out", "to": "f", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:generic-raymarcher",
        "node:box-torus-sdf",
        "node:sphere-raymarch",
        "type:vec3",
        "node:constant-vec3"
      ]
    },
    "node:kifs-sdf": {
      "title": "KIFS SDF",
      "titleType": "node",
      "tagline": "3D Kaleidoscopic IFS SDF for Larval-style fractals and raymarching",
      "description": "Outputs a signed distance field from a 3D Kaleidoscopic IFS (KIFS): iterative fold (abs), scale, offset, and rotation. Connect the position input to the generic raymarcher (SDF port); when orbit camera ro/rd are supported, use them for Larval-style camera. Parameters: scale, offset, rotation axis and angle, iterations, sphere radius.",
      "inputs": [
        {
          "name": "position",
          "type": "vec3",
          "description": "3D position to evaluate the SDF at (e.g. raymarch sample point)",
          "suggestedSources": [
            "type:vec3",
            "node:constant-vec3"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "Signed distance from the KIFS fractal",
          "suggestedTargets": [
            "node:generic-raymarcher",
            "node:mix",
            "node:smoothstep",
            "node:color-map"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "orbit-camera" },
          { "id": "c", "type": "kifs-sdf" },
          { "id": "d", "type": "generic-raymarcher" },
          { "id": "e", "type": "color-map" },
          { "id": "f", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "ro", "to": "d", "toPort": "ro" },
          { "from": "b", "fromPort": "rd", "to": "d", "toPort": "rd" },
          { "from": "a", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "sdf" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" },
          { "from": "e", "fromPort": "out", "to": "f", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:generic-raymarcher",
        "node:radial-repeat-sdf",
        "node:orbit-camera",
        "node:box-torus-sdf",
        "type:vec3"
      ]
    },
    "node:ether-sdf": {
      "title": "Ether SDF",
      "titleType": "node",
      "tagline": "3D SDF for Ether-fork style volumetric blobs: time-rotated domain and layered sine",
      "description": "Outputs a signed distance field (SDF) for the Ether-fork style effect: time-based 3D rotations (XZ and XY planes) and a composite formula (radial term plus layered sine). Connect to Generic SDF Raymarcher as the SDF input. Parameters: Rotate XZ/XY, Time Speed/Offset, Scale, Wobble Speed, Sine Amp, Position X/Y/Z. Position shifts the Ether field in 3D space (center offset), even when used as the raymarcher SDF. Set Time Speed to 0 to freeze the effect. Reference: Shadertoy ltfXzj (Ether by nimitz).",
      "inputs": [
        {
          "name": "position",
          "type": "vec3",
          "description": "3D position to evaluate the SDF at (e.g. raymarch sample point)",
          "suggestedSources": [
            "type:vec3",
            "node:constant-vec3"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "Signed distance (Ether-style volumetric blob field)",
          "suggestedTargets": [
            "node:generic-raymarcher",
            "node:mix",
            "node:smoothstep",
            "node:color-map"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "orbit-camera" },
          { "id": "c", "type": "ether-sdf" },
          { "id": "d", "type": "generic-raymarcher" },
          { "id": "e", "type": "color-map" },
          { "id": "f", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "ro", "to": "d", "toPort": "ro" },
          { "from": "b", "fromPort": "rd", "to": "d", "toPort": "rd" },
          { "from": "a", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "sdf" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" },
          { "from": "e", "fromPort": "out", "to": "f", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:generic-raymarcher",
        "node:radial-repeat-sdf",
        "node:displacement-3d",
        "node:sphere-raymarch",
        "type:vec3"
      ]
    },
    "node:displacement-3d": {
      "title": "Displace 3D",
      "titleType": "node",
      "tagline": "Signed 3D value-noise FBM displacement for raymarching and SDF distortion",
      "description": "Computes a vec3 displacement from 3D position (and time) using signed value-noise FBM. Input: vec3 position. Output: vec3 displacement to add to position (e.g. position + displacement before SDF evaluation in a raymarcher). Parameters: scale, octaves, lacunarity, gain, amplitude; time speed and offset for animation. Uses three offset samples for uncorrelated x,y,z components.",
      "inputs": [
        {
          "name": "position",
          "type": "vec3",
          "description": "3D position to sample displacement at (e.g. raymarch sample point)",
          "suggestedSources": [
            "type:vec3",
            "node:constant-vec3"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec3",
          "description": "Displacement vector to add to position",
          "suggestedTargets": [
            "node:add",
            "type:vec3",
            "node:radial-repeat-sdf"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "orbit-camera" },
          { "id": "c", "type": "radial-repeat-sdf" },
          { "id": "d", "type": "displacement-3d" },
          { "id": "e", "type": "generic-raymarcher" },
          { "id": "f", "type": "color-map" },
          { "id": "g", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "ro", "to": "e", "toPort": "ro" },
          { "from": "b", "fromPort": "rd", "to": "e", "toPort": "rd" },
          { "from": "a", "fromPort": "out", "to": "e", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "e", "toPort": "sdf" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "displacement" },
          { "from": "e", "fromPort": "out", "to": "f", "toPort": "in" },
          { "from": "f", "fromPort": "out", "to": "g", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:radial-repeat-sdf",
        "node:noise",
        "type:vec3",
        "node:constant-vec3"
      ]
    },
    "node:generic-raymarcher": {
      "title": "Generic SDF Raymarcher",
      "titleType": "node",
      "tagline": "Raymarch a scene using an SDF from the graph (vec3 → float); optional ro/rd and hit color output",
      "description": "Raymarch loop that uses a graph-derived SDF. Connect a node with vec3 position in and float out (e.g. Repeated Hex Prism SDF, Radial Repeat SDF) to the SDF input. Optionally connect Orbit Camera (or other) ro/rd for custom camera; optionally 3D Displacement. Output out (float) is glow; optional output color (vec3) is hit-position color with step-count fog (black on miss). Parameters: steps, glow, brightness; camera Ro X/Y/Z when ro/rd unconnected. Float parameters on SDF and displacement nodes used by generic-raymarcher now honor parameter input connections and automation with the same precedence rules as other nodes: automation lanes first, then parameter inputs (combined using the parameter's input mode), then uniforms or default values.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "UV or screen-space coordinates (used for default ray direction when rd unconnected)",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates"
          ]
        },
        {
          "name": "sdf",
          "type": "float",
          "description": "SDF from the graph; evaluated at each raymarch step",
          "suggestedSources": [
            "node:repeated-hex-prism-sdf",
            "node:radial-repeat-sdf",
            "node:kifs-sdf",
            "node:ether-sdf"
          ]
        },
        {
          "name": "displacement",
          "type": "vec3",
          "description": "Optional displacement added to sample position before SDF",
          "suggestedSources": [
            "node:displacement-3d"
          ]
        },
        {
          "name": "ro",
          "type": "vec3",
          "description": "Ray origin (e.g. from Orbit Camera); when unconnected uses Camera Ro X/Y/Z params",
          "suggestedSources": [
            "node:orbit-camera",
            "node:look-at-camera"
          ]
        },
        {
          "name": "rd",
          "type": "vec3",
          "description": "Ray direction (e.g. from Orbit Camera); when unconnected uses UV-based direction",
          "suggestedSources": [
            "node:orbit-camera",
            "node:look-at-camera"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "Raymarched result (glow/intensity)",
          "suggestedTargets": [
            "node:mix",
            "node:color-map",
            "node:final-output"
          ]
        },
        {
          "name": "color",
          "type": "vec3",
          "description": "Hit color with depth fog (position-based RGB minus step count); vec3(0) on miss",
          "suggestedTargets": [
            "node:final-output",
            "node:mix",
            "node:color-map"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "orbit-camera" },
          { "id": "c", "type": "hex-prism-sdf" },
          { "id": "d", "type": "generic-raymarcher" },
          { "id": "e", "type": "color-map" },
          { "id": "f", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "ro", "to": "d", "toPort": "ro" },
          { "from": "b", "fromPort": "rd", "to": "d", "toPort": "rd" },
          { "from": "a", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "sdf" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" },
          { "from": "e", "fromPort": "out", "to": "f", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:orbit-camera",
        "node:repeated-hex-prism-sdf",
        "node:radial-repeat-sdf",
        "node:displacement-3d",
        "node:box-torus-sdf",
        "node:sphere-raymarch"
      ]
    },
    "node:cylinder-cone": {
      "title": "Cylinder & Cone",
      "titleType": "node",
      "tagline": "3D cylinder and cone primitives using signed distance fields and raymarching",
      "description": "Renders 3D cylinder and cone shapes using signed distance fields (SDF) with raymarching. Choose Cylinder (radius and height) or Cone (base radius and height). Position, size, and rotation groups match the SDF node pattern. Use UV as input; output is a float suitable for mix, color-map, or final output. Ideal for pillars, cones, and rounded 3D primitives in a 2D shader.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Input UV coordinates to raymarch from",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "SDF raymarched result (distance-based value with glow)",
          "suggestedTargets": [
            "node:mix",
            "node:color-map",
            "node:final-output"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "cylinder-cone" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:box-torus-sdf",
        "node:sphere-raymarch",
        "type:vec2",
        "node:normalize"
      ]
    },
    "node:iridescent-tunnel": {
      "title": "Iridescent Tunnel",
      "titleType": "node",
      "tagline": "Volumetric raymarched infinite cylinders in 3D repeated, warped space with view-dependent iridescent coloring",
      "description": "Renders an infinite tunnel of repeating cylinders in 3D space with warp, Z-rotation, and soft volumetric accumulation. View-dependent iridescent coloring gives a shifting hue based on viewing angle. Parameters: repetition scale (cell size), tube size, warp frequency and strength, camera speed, rotation speed, raymarch steps, density, and iridescence mix and color shift. Connect UV to in; output is vec4 for Final Output or blending with mix/blend-mode.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "UV coordinates to raymarch from (e.g. from UV Coords)",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "RGBA color; connect to Final Output or blend with other nodes",
          "suggestedTargets": [
            "node:final-output",
            "node:blend-mode",
            "node:mix",
            "node:glow-bloom"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "iridescent-tunnel" },
          { "id": "c", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:sphere-raymarch",
        "node:cylinder-cone",
        "node:volume-rays",
        "type:vec2",
        "type:vec4"
      ]
    },
    "node:inflated-icosahedron": {
      "title": "Inflated Icosahedron",
      "titleType": "node",
      "tagline": "Raymarched 3D inflated icosahedron with domain folding, twist, per-face palette, soft shadows and lighting",
      "description": "Renders a raymarched 3D inflated icosahedron with icosahedron domain folding (knighty), twist around the nearest vertex (tdhooper), optional 3D polar repetition for seamless looping, per-face IQ-style palette coloring, soft shadows, ambient occlusion, and full lighting. Connect Screen position (e.g. UV Coords) to in; optionally connect Orbit Camera ro/rd to share camera. Output is vec3 RGB for Final Output or color nodes.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Screen position for ray direction (e.g. UV Coords)",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:fragment-coordinates"
          ]
        },
        {
          "name": "ro",
          "type": "vec3",
          "description": "Ray origin (camera position); when unconnected uses built-in orbit",
          "suggestedSources": [
            "node:orbit-camera",
            "node:look-at-camera"
          ]
        },
        {
          "name": "rd",
          "type": "vec3",
          "description": "Ray direction; when unconnected derived from in and ro",
          "suggestedSources": [
            "node:orbit-camera",
            "node:look-at-camera"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec3",
          "description": "Final RGB color; connect to Final Output or color nodes",
          "suggestedTargets": [
            "node:final-output",
            "node:color-grading",
            "node:mix"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "orbit-camera" },
          { "id": "c", "type": "inflated-icosahedron" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "ro", "to": "c", "toPort": "ro" },
          { "from": "b", "fromPort": "rd", "to": "c", "toPort": "rd" },
          { "from": "a", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:orbit-camera",
        "node:box-torus-sdf",
        "node:final-output",
        "type:vec3"
      ]
    },
    "node:iterated-inversion": {
      "title": "Iterated Inversion",
      "titleType": "node",
      "tagline": "Orbiting circle inversions with twist and gaussian blob accumulation for organic flowing blobs",
      "description": "Runs an internal loop of circle inversions around an orbiting center with angle twist, accumulating gaussian blobs into a vec3 color. Based on the \"Inversion 2\" effect (Inigo Quilez, Shadertoy 4t3SzN). Uses aspect-correct UV so circles stay round. Parameters: iterations, time speed, twist, orbit radius, scale (zoom); appearance: blob strength, sharpness, exposure; color: hue offset, hue spread, hue angle. Connect UV to in; output to Final Output or Color Grading.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "Input UV coordinates (e.g. from UV Coords)",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec3",
          "description": "Accumulated color from iterated inversions",
          "suggestedTargets": [
            "node:final-output",
            "node:color-grading",
            "node:mix",
            "node:blend-mode"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "iterated-inversion" },
          { "id": "c", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:fractal",
        "node:turbulence",
        "type:vec2",
        "type:vec3",
        "node:time"
      ]
    },
    "node:metaballs": {
      "title": "Metaballs",
      "titleType": "node",
      "tagline": "3D raymarched metaballs: soft blobs that blend where their fields overlap",
      "description": "Renders 3D metaballs using raymarching. Metaballs are soft blobs whose influence fields are summed; the visible surface is where the combined field exceeds a threshold. Blob count (2–6), radius, threshold, and orbit radius control the shape; blobs orbit around the scene center. Use Position to move the group, Animation for orbit speed, and Appearance for raymarch steps and glow. Connect UV to in and out to color-map or mix for shading.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "UV coordinates to raymarch from (e.g. from UV Coords)",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "Surface and glow value (float); use with color-map or mix",
          "suggestedTargets": [
            "node:color-map",
            "node:mix",
            "node:smoothstep",
            "node:final-output"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "metaballs" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:sphere-raymarch",
        "node:box-torus-sdf",
        "type:vec2",
        "node:color-map"
      ],
      "examples": [
        "Connect UV to in; output to Color Map or Mix for 3D metaballs (soft blobs that merge where fields overlap).",
        "Use with Orbit Camera or built-in orbit; adjust blob count, radius, threshold, and orbit radius for shape and motion.",
        "Feed output to Color Map or Mix for shading; layer with Primitives or Sphere Raymarch for mixed 3D scenes."
      ],
      "advanced": "Metaball surface is where the sum of blob influence fields exceeds a threshold; blobs orbit the scene center. More blobs (2–6) and higher raymarch steps improve quality at higher cost."
    },
    "node:sky-dome": {
      "title": "Sky / Dome",
      "titleType": "node",
      "tagline": "Procedural sky dome with zenith/horizon gradient and optional sun disc for backgrounds",
      "description": "Outputs a procedural sky as vec4 (RGBA) suitable for use behind raymarched 3D scenes. Sky color is blended from horizon to zenith; an optional sun disc is added when the view ray is close to the sun direction. Use Sky group to set zenith and horizon RGB and horizon sharpness; use Sun group to set direction (X,Y,Z), radius (radians), and intensity. Connect UV (e.g. from UV Coords) to in; connect out to mix, final output, or blend-mode nodes.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "UV coordinates to compute sky ray direction (e.g. from UV Coords)",
          "suggestedSources": [
            "type:vec2",
            "node:uv-coordinates",
            "node:translate",
            "node:scale"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "Sky color (RGB) and alpha 1.0",
          "suggestedTargets": [
            "node:mix",
            "node:final-output",
            "node:blending-modes"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "sky-dome" },
          { "id": "c", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:sphere-raymarch",
        "node:lighting-shading",
        "node:box-torus-sdf",
        "type:vec4"
      ],
      "examples": [
        "Connect UV to in; output to Mix or Final Output as background behind raymarched 3D (e.g. Primitives, Sphere Raymarch, Generic SDF Raymarcher).",
        "Set zenith and horizon colors in Sky group; add a sun disc with Sun direction and radius for a full sky look.",
        "Use as the second input to Mix with 3D node output (e.g. box-torus-sdf) so the sky shows where the ray misses geometry."
      ],
      "advanced": "Sky ray direction is derived from UV (same convention as 3D raymarch cameras). Sun disc is drawn when the view ray is close to the sun direction; intensity and radius control size and brightness."
    },
    "node:blending-modes": {
      "title": "Blending Modes",
      "titleType": "node",
      "tagline": "Ideal for combining elements using various blend modes like multiply, screen, overlay, and more",
      "description": "Applies blending modes to combine two color inputs, similar to layer blending in image editing software. The node supports multiple blend modes including Normal, Multiply, Screen, Overlay, Soft Light, Hard Light, Color Dodge, Color Burn, and more. Each mode produces different visual effects when combining colors. The blend can be controlled by opacity, and the blend source can come from the second input, a constant value, noise, or wave patterns. This is essential for creating complex compositing effects and layering multiple elements together.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "The base color to blend with the blend input"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The blended color result"
        }
      ],
      "relatedItems": [
        "node:blend-mode",
        "node:mix",
        "type:vec4"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "noise" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "blending-modes" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      }
    },
    "node:block-displacement": {
      "title": "Block Displacement",
      "titleType": "node",
      "tagline": "Perfect for creating glitch effects with variable-size blocks that displace coordinates",
      "description": "Creates glitch effects by dividing the coordinate space into variable-size blocks and applying displacement offsets. Larger blocks receive less offset while smaller blocks receive more offset, creating a distinctive glitch aesthetic. The blocks can be oriented horizontally or vertically, and the block boundaries, sizes, and offsets are determined by configurable parameters including block count, spacing chaos, and time-based animation. This effect is commonly used with block-color-glitch and block-edge-brightness nodes to create cohesive glitch compositions.",
      "inputs": [
        {
          "name": "in",
          "type": "vec2",
          "description": "The input 2D coordinates to apply block displacement to"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec2",
          "description": "The displaced coordinates after block transformation"
        }
      ],
      "relatedItems": [
        "node:block-color-glitch",
        "node:block-edge-brightness",
        "type:vec2",
        "node:time"
      ]
    },
    "node:compare": {
      "title": "Compare",
      "titleType": "node",
      "tagline": "Perfect for comparing two values and outputting binary results for conditional logic",
      "description": "Compares two input values using a selected comparison operation and outputs 1.0 if the condition is true, 0.0 otherwise. The available operations include equal (==), not equal (!=), less than (<), less than or equal (<=), greater than (>), and greater than or equal (>=). This is essential for creating conditional logic, thresholds, and binary masks based on value comparisons. The output can be used to drive other nodes or create selective effects.",
      "inputs": [
        {
          "name": "a",
          "type": "float",
          "description": "The first value to compare",
          "suggestedSources": [
            "type:float",
            "node:noise",
            "node:distance",
            "node:sine",
            "node:uv-coordinates"
          ]
        },
        {
          "name": "b",
          "type": "float",
          "description": "The second value to compare against",
          "suggestedSources": [
            "type:float",
            "node:constant-float",
            "node:smoothstep"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "1.0 if the comparison is true, 0.0 otherwise",
          "suggestedTargets": [
            "node:select",
            "node:mix",
            "node:step",
            "node:gradient-mask"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "constant-float" },
          { "id": "n3", "type": "compare" },
          { "id": "n4", "type": "color-map" },
          { "id": "n5", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n3", "toPort": "a" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "b" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" },
          { "from": "n4", "fromPort": "out", "to": "n5", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:select",
        "node:step",
        "type:float"
      ],
      "examples": [
        "Compare Noise or Distance to a threshold (e.g. equal, greater) for binary masks.",
        "Use output as condition for Select to pick one of two values.",
        "Drive Mix factor or gradient mask from comparison (1.0 or 0.0)."
      ],
      "advanced": "Output is 1.0 when condition true, 0.0 otherwise. For smooth transitions use Smoothstep; for hard edges use Step."
    },
    "node:select": {
      "title": "Select",
      "titleType": "node",
      "tagline": "Ideal for choosing between two values based on a condition for conditional routing",
      "description": "Selects between two input values based on a condition. If the condition is greater than 0.5, it returns the true value; otherwise, it returns the false value. This creates a simple conditional branch that allows routing different values through the node graph based on conditions. The condition is typically a float value from 0.0 to 1.0, where values above 0.5 are considered true. This is useful for creating conditional effects, switching between different inputs, or implementing if-else logic in shader graphs.",
      "inputs": [
        {
          "name": "condition",
          "type": "float",
          "description": "The condition value (values > 0.5 select trueValue)",
          "suggestedSources": [
            "type:float",
            "node:compare",
            "node:step",
            "node:smoothstep",
            "node:noise"
          ]
        },
        {
          "name": "trueValue",
          "type": "float",
          "description": "The value returned when condition is true",
          "suggestedSources": [
            "type:float",
            "node:constant-float",
            "node:color-map",
            "node:mix"
          ]
        },
        {
          "name": "falseValue",
          "type": "float",
          "description": "The value returned when condition is false",
          "suggestedSources": [
            "type:float",
            "node:constant-float",
            "node:color-map",
            "node:mix"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The selected value based on the condition",
          "suggestedTargets": [
            "node:mix",
            "node:color-map",
            "node:final-output",
            "node:gradient-mask"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "constant-float" },
          { "id": "n3", "type": "constant-float" },
          { "id": "n4", "type": "select" },
          { "id": "n5", "type": "color-map" },
          { "id": "n6", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n4", "toPort": "condition" },
          { "from": "n2", "fromPort": "out", "to": "n4", "toPort": "trueValue" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "falseValue" },
          { "from": "n4", "fromPort": "out", "to": "n5", "toPort": "in" },
          { "from": "n5", "fromPort": "out", "to": "n6", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:compare",
        "node:mix",
        "type:float"
      ]
    },
    "node:mask-composite-float": {
      "title": "Mask BW",
      "titleType": "node",
      "tagline": "Composites foreground over background using a float mask; dark areas show background, bright areas show foreground.",
      "description": "Blends two float values (background and foreground) using a mask. Where the mask is dark (low values), the background appears; where it is bright (high values), the foreground appears. Connect a float mask (e.g. from Noise, Step, or Smoothstep) to the mask input, and set or connect the background and foreground values. Useful for masking patterns, blending values, or driving mix factors.",
      "inputs": [
        {
          "name": "bg",
          "type": "float",
          "description": "Background value (shown where mask is dark)",
          "suggestedSources": ["type:float", "node:constant-float", "node:noise"]
        },
        {
          "name": "mask",
          "type": "float",
          "description": "Mask value 0–1: dark = bg, bright = fg",
          "suggestedSources": ["type:float", "node:noise", "node:step", "node:smoothstep"]
        },
        {
          "name": "fg",
          "type": "float",
          "description": "Foreground value (shown where mask is bright)",
          "suggestedSources": ["type:float", "node:constant-float", "node:noise"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "Result of mixing bg and fg by mask",
          "suggestedTargets": ["node:color-map", "node:mix", "node:mask-composite-vec3"]
        }
      ],
      "parameters": [
        { "name": "Background", "description": "Used for bg when nothing is connected. This value appears where the mask is dark (0); set to 0 for black, 1 for white in grayscale." },
        { "name": "Mask", "description": "Default mask value when mask input is unconnected. 0 = show background everywhere; 1 = show foreground; in between = blend." },
        { "name": "Foreground", "description": "Used for fg when nothing is connected. This value appears where the mask is bright (1); set to control the bright areas of the result." }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "constant-float" },
          { "id": "n3", "type": "constant-float" },
          { "id": "n4", "type": "mask-composite-float" },
          { "id": "n5", "type": "color-map" },
          { "id": "n6", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n4", "toPort": "bg" },
          { "from": "n2", "fromPort": "out", "to": "n4", "toPort": "mask" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "fg" },
          { "from": "n4", "fromPort": "out", "to": "n5", "toPort": "in" },
          { "from": "n5", "fromPort": "out", "to": "n6", "toPort": "in" }
        ]
      },
      "relatedItems": ["node:mask-composite-vec3", "node:compare", "node:mix", "type:float"]
    },
    "node:mask-composite-vec3": {
      "title": "Mask Color",
      "titleType": "node",
      "tagline": "Composites colored foreground over colored background using a float mask.",
      "description": "Blends two colors (vec3 background and foreground) using a mask. Dark mask areas show the background color; bright areas show the foreground. Connect the output of Color Map or another color source to bg and fg, and a float mask to the mask input. Ideal for combining two color layers or applying masks to colored results.",
      "inputs": [
        {
          "name": "bg",
          "type": "vec3",
          "description": "Background color (shown where mask is dark)",
          "suggestedSources": ["type:vec3", "node:color-map", "node:mix"]
        },
        {
          "name": "mask",
          "type": "float",
          "description": "Mask 0–1: dark = bg, bright = fg",
          "suggestedSources": ["type:float", "node:noise", "node:step", "node:smoothstep"]
        },
        {
          "name": "fg",
          "type": "vec3",
          "description": "Foreground color (shown where mask is bright)",
          "suggestedSources": ["type:vec3", "node:color-map", "node:mix"]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec3",
          "description": "Result color from mixing bg and fg by mask",
          "suggestedTargets": ["node:final-output", "node:mix", "node:blend-mode"]
        }
      ],
      "parameters": [
        { "name": "Mask", "description": "Default mask value when mask input is unconnected. 0 = show background color everywhere; 1 = show foreground; in between = blend between the two colors." }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-vec3" },
          { "id": "n2", "type": "constant-float" },
          { "id": "n3", "type": "constant-vec3" },
          { "id": "n4", "type": "mask-composite-vec3" },
          { "id": "n5", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n4", "toPort": "bg" },
          { "from": "n2", "fromPort": "out", "to": "n4", "toPort": "mask" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "fg" },
          { "from": "n4", "fromPort": "out", "to": "n5", "toPort": "in" }
        ]
      },
      "relatedItems": ["node:mask-composite-float", "node:color-map", "node:mix", "type:vec3"]
    },
    "node:one-minus": {
      "title": "One Minus",
      "titleType": "node",
      "tagline": "Perfect for inverting values in the 0-1 range (calculates 1.0 - input)",
      "description": "Subtracts the input value from 1.0, effectively inverting values in the 0-1 range. When the input is 0.0, the output is 1.0; when the input is 1.0, the output is 0.0. This is commonly used for inverting masks, flipping gradients, or creating inverse relationships. The operation is equivalent to (1.0 - input) and is a fundamental utility for many shader operations that require inverted values.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value to invert (subtract from 1.0)"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The inverted value (1.0 - input)"
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "one-minus" },
          { "id": "n3", "type": "color-map" },
          { "id": "n4", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n2", "toPort": "in" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "in" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:negate",
        "node:subtract",
        "type:float"
      ]
    },
    "node:negate": {
      "title": "Negate",
      "titleType": "node",
      "tagline": "Use this to negate (flip sign) of a value, converting positive to negative and vice versa",
      "description": "Negates the input value by multiplying it by -1.0, effectively flipping its sign. Positive values become negative, and negative values become positive. Zero remains zero. This is useful for reversing directions, inverting offsets, or creating mirror effects. The operation is equivalent to (-input) and is a fundamental utility for many mathematical operations.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value to negate"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The negated value (-input)"
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "negate" },
          { "id": "n3", "type": "color-map" },
          { "id": "n4", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n2", "toPort": "in" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "in" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:one-minus",
        "node:multiply",
        "type:float"
      ],
      "examples": [
        "Negate(offset) to reverse direction of Translate or displacement.",
        "Flip sign of Sine or a difference for mirrored motion or symmetry.",
        "Use with One Minus when you need full sign flip (not just 0–1 invert)."
      ]
    },
    "node:reciprocal": {
      "title": "Reciprocal",
      "titleType": "node",
      "tagline": "Ideal for calculating the reciprocal (1.0 / input) for division operations",
      "description": "Calculates the reciprocal of the input value by dividing 1.0 by the input. The reciprocal of a number is its multiplicative inverse, so multiplying a value by its reciprocal equals 1.0. This is useful for inverting scales, converting rates to periods, or performing division when you need to multiply by the inverse. Be careful with values near zero, as the reciprocal approaches infinity.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value to calculate the reciprocal of (must not be zero)"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The reciprocal value (1.0 / input)"
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "reciprocal" },
          { "id": "n3", "type": "color-map" },
          { "id": "n4", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n2", "toPort": "in" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "in" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:divide",
        "node:multiply",
        "type:float"
      ],
      "examples": [
        "Reciprocal(Length or Distance) for 1/r falloff (avoid zero input).",
        "Multiply by Reciprocal instead of Divide when same divisor is reused.",
        "Invert a scale factor (e.g. 1/period for frequency)."
      ],
      "advanced": "Input must not be zero; use Max(input, small) or branch to avoid division by zero."
    },
    "node:clamp-01": {
      "title": "Clamp 01",
      "titleType": "node",
      "tagline": "Use this to clamp values to the 0.0-1.0 range, ensuring they stay within valid bounds",
      "description": "Clamps the input value to the range 0.0 to 1.0. Values below 0.0 become 0.0, values above 1.0 become 1.0, and values within the range remain unchanged. This is a specialized version of the clamp node with fixed bounds, commonly used in shader programming. It's equivalent to clamp(input, 0.0, 1.0) and is essential for ensuring values stay within normalized ranges, particularly for colors, masks, and blend factors.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value to clamp to 0.0-1.0 range"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The clamped value (between 0.0 and 1.0)"
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "clamp-01" },
          { "id": "n3", "type": "color-map" },
          { "id": "n4", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n2", "toPort": "in" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "in" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:clamp",
        "node:saturate",
        "type:float"
      ],
      "examples": [
        "Clamp Sine or Noise to 0–1 before using as mask or Mix factor.",
        "Ensure a value is in valid range for Color Map or blend inputs.",
        "Same as Saturate; use when you want explicit 0–1 bounds."
      ]
    },
    "node:saturate": {
      "title": "Saturate",
      "titleType": "node",
      "tagline": "Same as Clamp 01, a common shader programming term for clamping to 0-1 range",
      "description": "Saturates the input value by clamping it to the 0.0-1.0 range. This is identical to the Clamp 01 node but uses the common shader programming term 'saturate'. The function ensures values stay within the normalized range, which is essential for color channels, blend factors, and many shader operations. Values below 0.0 become 0.0, values above 1.0 become 1.0, and values within range remain unchanged.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value to saturate (clamp to 0.0-1.0)"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The saturated value (clamped between 0.0 and 1.0)"
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "saturate" },
          { "id": "n3", "type": "color-map" },
          { "id": "n4", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n2", "toPort": "in" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "in" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:clamp-01",
        "node:clamp",
        "type:float"
      ],
      "examples": [
        "Saturate after Add or Multiply to keep result in 0–1 for masks or colors.",
        "Identical to Clamp 01; use for shader-style naming in 0–1 clamping.",
        "Apply to Dot Product or signed value before Mix for safe blend factor."
      ]
    },
    "node:sign": {
      "title": "Sign",
      "titleType": "node",
      "tagline": "Ideal for extracting the sign of a value, returning -1.0, 0.0, or 1.0",
      "description": "Returns the sign of the input value: -1.0 for negative values, 0.0 for zero, and 1.0 for positive values. This is useful for determining direction, creating conditional logic based on sign, or extracting the sign component of a value. The sign function is commonly used in mathematical operations where you need to know whether a value is positive or negative without caring about its magnitude.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value to get the sign of"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The sign value (-1.0, 0.0, or 1.0)"
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "sign" },
          { "id": "n3", "type": "color-map" },
          { "id": "n4", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n2", "toPort": "in" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "in" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:absolute",
        "node:negate",
        "type:float"
      ],
      "examples": [
        "Sign(offset or direction) to get -1, 0, or 1 for branching or flip.",
        "Use with Multiply to apply direction without magnitude.",
        "Detect positive/negative for conditional logic or Select-style routing."
      ]
    },
    "node:round": {
      "title": "Round",
      "titleType": "node",
      "tagline": "Perfect for rounding values to the nearest integer for quantization and discrete steps",
      "description": "Rounds the input value to the nearest integer. Values exactly halfway between integers round to the nearest even integer (banker's rounding). This is useful for quantizing values, creating discrete steps, or converting continuous values to integer-like values. Rounding is commonly used for pixel-perfect effects, grid snapping, or creating stepped animations.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value to round to the nearest integer"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The rounded value (nearest integer)"
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "round" },
          { "id": "n3", "type": "color-map" },
          { "id": "n4", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n2", "toPort": "in" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "in" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:floor",
        "node:ceil",
        "node:fract",
        "type:float"
      ],
      "examples": [
        "Round(UV × N) or Round(Time) for discrete steps or quantized values.",
        "Quantize a 0–1 value for stepped Color Map or banding effects.",
        "Banker's rounding (half rounds to even); use Floor/Ceil for deterministic direction."
      ]
    },
    "node:truncate": {
      "title": "Truncate",
      "titleType": "node",
      "tagline": "Use this to truncate (remove fractional part) of a value, rounding towards zero",
      "description": "Truncates the input value by removing its fractional part, effectively rounding towards zero. Positive values are rounded down, and negative values are rounded up (towards zero). This is different from floor, which always rounds down. Truncation is useful for creating discrete values, quantizing, or extracting the integer component of a number. The result is always closer to zero than the input.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The value to truncate (remove fractional part)"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The truncated value (fractional part removed)"
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "truncate" },
          { "id": "n3", "type": "color-map" },
          { "id": "n4", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n2", "toPort": "in" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "in" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:floor",
        "node:round",
        "node:fract",
        "type:float"
      ],
      "examples": [
        "Truncate(Time or value) to drop fractional part (round toward zero).",
        "Same as Floor for positive values; differs for negative (truncate goes toward zero).",
        "Get integer part of a float for indexing or discrete bands."
      ]
    },
    "node:lerp": {
      "title": "Lerp",
      "titleType": "node",
      "tagline": "Linear interpolation (alias for Mix) for smoothly blending between two values",
      "description": "Performs linear interpolation (lerp) between two values, which is identical to the Mix node. When the blend factor (t) is 0.0, it returns the first value (a). When t is 1.0, it returns the second value (b). Values in between are linearly interpolated. The term 'lerp' is commonly used in game development and graphics programming as shorthand for linear interpolation. This node provides the same functionality as Mix but with a different name for familiarity.",
      "inputs": [
        {
          "name": "a",
          "type": "float",
          "description": "The first value (returned when t = 0.0)",
          "suggestedSources": [
            "type:float",
            "node:constant-float",
            "node:sine",
            "node:noise",
            "node:color-map"
          ]
        },
        {
          "name": "b",
          "type": "float",
          "description": "The second value (returned when t = 1.0)",
          "suggestedSources": [
            "type:float",
            "node:constant-float",
            "node:sine",
            "node:noise",
            "node:color-map"
          ]
        },
        {
          "name": "t",
          "type": "float",
          "description": "The blend factor (typically 0.0 to 1.0)",
          "suggestedSources": [
            "type:float",
            "node:smoothstep",
            "node:uv-coordinates"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The linearly interpolated value between a and b",
          "suggestedTargets": [
            "node:final-output",
            "node:color-map",
            "node:blend-mode",
            "node:translate"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "constant-float" },
          { "id": "n3", "type": "constant-float" },
          { "id": "n4", "type": "lerp" },
          { "id": "n5", "type": "color-map" },
          { "id": "n6", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n4", "toPort": "a" },
          { "from": "n2", "fromPort": "out", "to": "n4", "toPort": "b" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "t" },
          { "from": "n4", "fromPort": "out", "to": "n5", "toPort": "in" },
          { "from": "n5", "fromPort": "out", "to": "n6", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:mix",
        "node:smoothstep",
        "type:float"
      ]
    },
    "node:swizzle": {
      "title": "Swizzle",
      "titleType": "node",
      "tagline": "Perfect for reordering and rearranging vector components (xy, yx, xyz, etc.)",
      "description": "Reorders and rearranges vector components using swizzle patterns. Swizzling allows you to access vector components in different orders, duplicate components, or extract subsets. Common patterns include 'xy' (extract x and y), 'yx' (swap x and y), 'xyz' (extract first three), 'zyx' (reverse order), 'xyzw' (all components), and 'wzyx' (reverse all). The node supports common 2, 3, and 4 component patterns. This is essential for manipulating vector data, extracting specific components, or reordering coordinates.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "The input vector to swizzle"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The swizzled vector with reordered components"
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-vec4" },
          { "id": "n2", "type": "swizzle" },
          { "id": "n3", "type": "split-vector" },
          { "id": "n4", "type": "color-map" },
          { "id": "n5", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n2", "toPort": "in" },
          { "from": "n2", "fromPort": "out", "to": "n3", "toPort": "in" },
          { "from": "n3", "fromPort": "x", "to": "n4", "toPort": "in" },
          { "from": "n4", "fromPort": "out", "to": "n5", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:split-vector",
        "node:combine-vector",
        "type:vec4"
      ]
    },
    "node:split-vector": {
      "title": "Split Vector",
      "titleType": "node",
      "tagline": "Ideal for splitting a vector into its individual components (x, y, z, w)",
      "description": "Splits a vector into its individual components, outputting each component (x, y, z, w) as separate float outputs. This allows you to access and manipulate individual components of a vector independently. The node takes a vec4 input and outputs four float values representing the x, y, z, and w components. This is essential for extracting specific components, performing per-component operations, or routing individual components to different parts of the node graph.",
      "inputs": [
        {
          "name": "in",
          "type": "vec4",
          "description": "The vector to split into components",
          "suggestedSources": [
            "type:vec2",
            "type:vec3",
            "type:vec4",
            "node:uv-coordinates",
            "node:polar-coordinates",
            "node:constant-vec2"
          ]
        }
      ],
      "outputs": [
        {
          "name": "x",
          "type": "float",
          "description": "The x component of the input vector",
          "suggestedTargets": [
            "node:arc-tangent-2",
            "node:combine-vector",
            "node:multiply",
            "node:add"
          ]
        },
        {
          "name": "y",
          "type": "float",
          "description": "The y component of the input vector",
          "suggestedTargets": [
            "node:arc-tangent-2",
            "node:combine-vector",
            "node:multiply",
            "node:add"
          ]
        },
        {
          "name": "z",
          "type": "float",
          "description": "The z component of the input vector",
          "suggestedTargets": [
            "node:combine-vector",
            "node:multiply",
            "node:color-map"
          ]
        },
        {
          "name": "w",
          "type": "float",
          "description": "The w component of the input vector",
          "suggestedTargets": [
            "node:combine-vector",
            "node:mix"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-vec4" },
          { "id": "n2", "type": "split-vector" },
          { "id": "n3", "type": "color-map" },
          { "id": "n4", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n2", "toPort": "in" },
          { "from": "n2", "fromPort": "x", "to": "n3", "toPort": "in" },
          { "from": "n3", "fromPort": "out", "to": "n4", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:combine-vector",
        "node:swizzle",
        "type:vec4"
      ],
      "examples": [
        "Split UV or vec4 into x, y (and z, w) for Arc Tangent 2 or per-component math.",
        "Extract one channel (e.g. x or z) to feed to Color Map or Mix.",
        "Route components to different nodes (e.g. x to one pattern, y to another)."
      ]
    },
    "node:combine-vector": {
      "title": "Combine Vector",
      "titleType": "node",
      "tagline": "Perfect for combining individual float values into a vector (vec2, vec3, or vec4)",
      "description": "Combines individual float values into a vector. The node takes four float inputs (x, y, z, w) and outputs a vec4, but the output type can be configured to vec2 or vec3 as needed. The compiler handles type promotion/demotion based on how the output is used. This is the inverse operation of Split Vector and is essential for constructing vectors from individual components, creating coordinates from separate values, or assembling color values from individual channels.",
      "inputs": [
        {
          "name": "x",
          "type": "float",
          "description": "The x component of the output vector",
          "suggestedSources": [
            "type:float",
            "node:split-vector",
            "node:constant-float",
            "node:uv-coordinates"
          ]
        },
        {
          "name": "y",
          "type": "float",
          "description": "The y component of the output vector",
          "suggestedSources": [
            "type:float",
            "node:split-vector",
            "node:constant-float",
            "node:uv-coordinates"
          ]
        },
        {
          "name": "z",
          "type": "float",
          "description": "The z component of the output vector",
          "suggestedSources": [
            "type:float",
            "node:split-vector",
            "node:constant-float",
            "node:color-map"
          ]
        },
        {
          "name": "w",
          "type": "float",
          "description": "The w component of the output vector",
          "suggestedSources": [
            "type:float",
            "node:split-vector",
            "node:constant-float"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec4",
          "description": "The combined vector (type promoted/demoted by compiler as needed)",
          "suggestedTargets": [
            "node:translate",
            "node:uv-coordinates",
            "node:mix",
            "node:split-vector"
          ]
        }
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "n1", "type": "constant-float" },
          { "id": "n2", "type": "constant-float" },
          { "id": "n3", "type": "constant-float" },
          { "id": "n4", "type": "constant-float" },
          { "id": "n5", "type": "combine-vector" },
          { "id": "n6", "type": "split-vector" },
          { "id": "n7", "type": "color-map" },
          { "id": "n8", "type": "final-output" }
        ],
        "connections": [
          { "from": "n1", "fromPort": "out", "to": "n5", "toPort": "x" },
          { "from": "n2", "fromPort": "out", "to": "n5", "toPort": "y" },
          { "from": "n3", "fromPort": "out", "to": "n5", "toPort": "z" },
          { "from": "n4", "fromPort": "out", "to": "n5", "toPort": "w" },
          { "from": "n5", "fromPort": "out", "to": "n6", "toPort": "in" },
          { "from": "n6", "fromPort": "x", "to": "n7", "toPort": "in" },
          { "from": "n7", "fromPort": "out", "to": "n8", "toPort": "in" }
        ]
      },
      "relatedItems": [
        "node:split-vector",
        "node:swizzle",
        "type:vec4"
      ],
      "examples": [
        "Combine x, y from constants or Split Vector for vec2 UV or offset (e.g. Translate).",
        "Build vec3 from R, G, B floats (e.g. from Color Map or separate patterns).",
        "Inverse of Split Vector: reassemble components after per-channel operations."
      ]
    },
    "node:bayer-dither": {
      "title": "Bayer Dither",
      "titleType": "node",
      "tagline": "Ideal for applying Bayer dithering to reduce banding artifacts and create ordered dither patterns",
      "description": "Applies Bayer dithering to a float value using fragment coordinates to create an ordered dither pattern. Bayer dithering uses a threshold matrix to add controlled noise that breaks up banding artifacts in gradients and color transitions. The dithering strength and pixel size can be configured to control the intensity and scale of the dither pattern. This is particularly useful for reducing color banding in gradients, especially when working with limited color depth or when creating retro/vintage aesthetics that benefit from dithering artifacts.",
      "inputs": [
        {
          "name": "in",
          "type": "float",
          "description": "The input value to apply dithering to",
          "suggestedSources": [
            "type:float",
            "node:color-map",
            "node:noise",
            "node:smoothstep",
            "node:oklch-color-map-threshold"
          ]
        },
        {
          "name": "fragCoord",
          "type": "vec2",
          "description": "Fragment coordinates for dithering pattern calculation",
          "suggestedSources": [
            "node:fragment-coordinates",
            "node:uv-coordinates"
          ]
        },
        {
          "name": "resolution",
          "type": "vec2",
          "description": "Screen resolution for dithering calculations",
          "suggestedSources": [
            "node:resolution"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "float",
          "description": "The dithered value with Bayer pattern applied",
          "suggestedTargets": [
            "node:color-map",
            "node:oklch-color-map-threshold",
            "node:mix"
          ]
        }
      ],
      "relatedItems": [
        "node:oklch-color-map-threshold",
        "type:float",
        "node:fragment-coordinates"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "noise" },
          { "id": "c", "type": "fragment-coordinates" },
          { "id": "d", "type": "resolution" },
          { "id": "e", "type": "bayer-dither" },
          { "id": "f", "type": "color-map" },
          { "id": "g", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "e", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "e", "toPort": "fragCoord" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "resolution" },
          { "from": "e", "fromPort": "out", "to": "f", "toPort": "in" },
          { "from": "f", "fromPort": "out", "to": "g", "toPort": "in" }
        ]
      }
    },
    "node:tone-mapping": {
      "title": "Tone Mapping",
      "titleType": "node",
      "tagline": "Perfect for adjusting exposure, contrast, and saturation for final color correction",
      "description": "Applies tone mapping adjustments to color values, including exposure (brightness), contrast, and saturation. Exposure multiplies the color values to adjust overall brightness. Contrast centers the values around 0.5 and scales them to increase or decrease contrast. Saturation adjusts color intensity by mixing the color with its luminance (grayscale version). These adjustments are essential for final color correction and achieving the desired look. Tone mapping is typically applied near the end of the rendering pipeline to fine-tune the final appearance.",
      "inputs": [
        {
          "name": "in",
          "type": "vec3",
          "description": "The input RGB color to apply tone mapping to",
          "suggestedSources": [
            "node:color-map",
            "node:oklch-color-map-bezier",
            "node:color-grading",
            "node:mix",
            "node:blend-mode"
          ]
        }
      ],
      "outputs": [
        {
          "name": "out",
          "type": "vec3",
          "description": "The tone-mapped color with exposure, contrast, and saturation adjustments",
          "suggestedTargets": [
            "node:final-output",
            "node:color-grading"
          ]
        }
      ],
      "relatedItems": [
        "node:color-grading",
        "node:multiply",
        "type:vec3"
      ],
      "setupExampleGraph": {
        "nodes": [
          { "id": "a", "type": "uv-coordinates" },
          { "id": "b", "type": "noise" },
          { "id": "c", "type": "color-map" },
          { "id": "d", "type": "tone-mapping" },
          { "id": "e", "type": "final-output" }
        ],
        "connections": [
          { "from": "a", "fromPort": "out", "to": "b", "toPort": "in" },
          { "from": "b", "fromPort": "out", "to": "c", "toPort": "in" },
          { "from": "c", "fromPort": "out", "to": "d", "toPort": "in" },
          { "from": "d", "fromPort": "out", "to": "e", "toPort": "in" }
        ]
      },
      "examples": [
        "Chain Color Map or Color Grading → Tone Mapping → Output to adjust exposure and contrast before display.",
        "Use after Glow or post-process nodes to tame highlights and set final saturation.",
        "Place near the end of the pipeline; combine with Color Grading for full control over shadows, midtones, and highlights."
      ],
      "advanced": "Exposure scales luminance; contrast centers around 0.5 and compresses or expands range; saturation mixes color with its luminance. Order matters: tone mapping after color grading gives a final trim, before grading affects the curve input."
    },
    "node:final-output": {
      "title": "Output",
      "titleType": "node",
      "tagline": "This is where your image comes from. Connect a color (or a float through Color Map) here to see it on screen.",
      "description": "The Output node is the end of the graph: whatever color you connect to its input is what you see in the preview. It has one input that accepts a color (vec3 RGB). If you connect a float instead (e.g. from Noise), the app will treat it as grayscale. Every graph needs exactly one Output node. It has no parameters and no outputs—it only displays what you plug in.",
      "inputs": [
        {
          "name": "in",
          "type": "vec3",
          "description": "The color to show on screen. Connect Color Map (for grayscale from a float), Mix, Blend, or any node that outputs color.",
          "suggestedSources": [
            "node:color-map",
            "node:tone-mapping",
            "node:color-grading",
            "node:blend-mode",
            "node:mix",
            "node:glow-bloom"
          ]
        }
      ],
      "outputs": [],
      "setupExampleGraph": {
        "nodes": [
          {
            "id": "a",
            "type": "uv-coordinates"
          },
          {
            "id": "b",
            "type": "noise"
          },
          {
            "id": "c",
            "type": "color-map"
          },
          {
            "id": "d",
            "type": "final-output"
          }
        ],
        "connections": [
          {
            "from": "a",
            "fromPort": "out",
            "to": "b",
            "toPort": "in"
          },
          {
            "from": "b",
            "fromPort": "out",
            "to": "c",
            "toPort": "in"
          },
          {
            "from": "c",
            "fromPort": "out",
            "to": "d",
            "toPort": "in"
          }
        ]
      },
      "relatedItems": [
        "node:color-map",
        "type:vec3"
      ],
      "examples": [
        "Connect Color Map (or Tone Mapping, Blend, Mix) output to in to see your image in the preview.",
        "Simplest chain: UV → Noise → Color Map → Output.",
        "Every graph needs exactly one Output; connect your final color or post-process result here."
      ]
    }
  }
}
